















Inhaltsverzeichnis

1 Einleitung
    1.1 Einführung
    1.2 Aufgabenstellung
    1.3 Aufbau der vorliegenden Arbeit
2 Grundlagen
    2.1 Epidemiologie
        2.1.1 Epidemiologische Kennzahlen und Definitionen
        2.1.2 Epidemiologie in Deutschland
        2.1.3 Meningokokken
        2.1.4 Arbeit des Nationalen Referenzzentrums für Meningokokken
    2.2 Geografische Informationssysteme
        2.2.1 Räumliches Datenmodell
        2.2.2 Koordinaten und Kartenprojektionen
        2.2.3 Topologie
        2.2.4 Einsatz von Geoinformationen und Statistik in der Epidemiologie
3 Definition der Anforderungen
    3.1 Zielbestimmungen 
        3.1.1 Musskriterien
        3.1.2 Wunschkriterien 
        3.1.3 Abgrenzungskriterien
    3.2 Produkt-Einsatz
        3.2.1 Anwendungsbereiche
        3.2.2 Zielgruppen
        3.2.3 Betriebsbedingungen
    3.3 Produktfunktionen
    3.4 Produkt-Daten
        3.4.1 Eingabedaten
        3.4.2 Ausgabedaten
    3.5 Produkt-Leistungen
    3.6 Qualitätsanforderungen
    3.7 Technische Produktumgebung
        3.7.1 Hardware-Umgebung
        3.7.2 Software-Umgebung
    3.8 Entwicklungsumgebung
        3.8.1 Programmiersprache
        3.8.2 Entwicklungswerkzeuge
4 Untersuchung der Voraussetzungen
    4.1 Web-basierte Systeme zur Überwachung von Infektionen
    4.2 Anforderungen an ein web-basiertes epidemiologisches GIS
        4.2.1 Reichhaltige Internetanwendung als Benutzerschnittstelle
        4.2.2 Geografisches Informationssystem
        4.2.3 Aktualisierung der Daten
        4.2.4 Automatische Identifizierung von Clustern
    4.3 Anwendungsrelevante freie Softwarepakete
        4.3.1 Web-basierte Anwendungen
        4.3.2 Datenbanksysteme
        4.3.3 Geografische Informationssysteme
        4.3.4 Statistiksoftware
5 Konzepte
    5.1 Datenmodell, Präsentation und Programmsteuerung
        5.1.1 Globale und benutzerspezifische Daten
        5.1.2 Präsentation der Informationen
        5.1.3 Wohldefinierte Zustandsänderungen
    5.2 Leichte Erweiterbarkeit
        5.2.1 Dynamische Karten- und Ebenenparameter
        5.2.2 Änderbarkeit der Kartendefinition des MapServers
        5.2.3 Aufteilung der Systemkomponenten in Pakete
        5.2.4 Erweiterungen an externen Schnittstellen
    5.3 Kapselung des MapServers und Caching
        5.3.1 Datenschutz durch indirekten Zugriff
        5.3.2 Optimierte Antwortzeiten durch Caching
6 Implementierungsdetails
    6.1 Serverseitige Anwendung
        6.1.1 Initialisierung der Karte
        6.1.2 Export der Karte in unterschiedliche Dateiformate
        6.1.3 Zustandsänderung durch Aktionen in Struts
    6.2 Definition von Karten für den MapServer
        6.2.1 Inzidenzdarstellung
        6.2.2 Darstellung von Clustern
        6.2.3 Streuung von Punktinformationen
    6.3 Clientanwendung mit OpenLaszlo
        6.3.1 Dynamischer Aufbau der Benutzeroberfläche
        6.3.2 Kommunikation zwischen Laszlo und Struts
    6.4 Serverseitige Clusteridentifizerung mittels SaTScan
7 Zusammenfassung und Ausblick
    7.1 Zusammenfassung
    7.2 Erweiterungsmöglichkeiten
        7.2.1 Integration des Statistikpaketes R
        7.2.2 Animationen über die Dimension Zeit
        7.2.3 Ausbau der Benutzeroberfläche
Appendix A Softwaresystem EpiDeGIS
    A.1 Installationsanleitung unter Linux
        A.1.1 Grundlagen
        A.1.2 Installation der benötigten Softwarekomponenten
        A.1.3 Einrichtung der Datenbank
        A.1.4 Konfiguration des Tomcat Servlet-Containers
        A.1.5 Installation und Einrichtung der EpiDeGIS-Komponenten
    A.2 Clientseitiger Kartenbetrachter
        A.2.1 Benutzeroberfläche
        A.2.2 Klassen
    A.3 Serverseitiger Kartenverwalter
        A.3.1 Konfiguration
        A.3.2 Klassen
    A.4 PostgreSQL Datenbank
        A.4.1 Tabellen
        A.4.2 Abfragen
        A.4.3 Funktionen und Sichten
    A.5 Automatisierte Clusteranalyse
    A.6 Mapserver zur Kartenerzeugung
    A.7 Datenübertragung und Import
        A.7.1 Clientseitige Datenübertragung
        A.7.2 Serverseitiger Import
Appendix B Datei-Listings
Appendix C Abkürzungen





<cha:Intro>Einleitung

1.1 Einführung

1.2 Aufgabenstellung

1.3 Aufbau der vorliegenden Arbeit



Grundlagen

Das folgende Kapitel vermittelt die Grundlagen, die für 
das Verständnis dieser Arbeit notwendig sind. Es gibt 
einen Einblick in die Epidemiologie und die 
Geografischen Informationssysteme (GIS). Die Inhalte 
der einzelnen Abschnitte beschränken sich dabei auf die 
Teilbereiche dieser Disziplinen, die in der 
vorliegenden Diplomarbeit verwendet werden.

2.1 Epidemiologie

  Definition

Die Epidemiologie ist die Lehre der Verbreitung und 
Ursachen von gesundheitsrelevanten Zuständen und 
Ereignissen in Bevölkerungsgruppen. Das 
epidemiologische Wissen wird im Allgemeinen angewandt, 
um Gesundheitsprobleme der Bevölkerung zu beobachten 
und so gut wie möglich zu kontrollieren. [last:2000]

Diese Wissenschaft erfasst und bewertet 
Erkrankungshäufungen. Epidemiologen berücksichtigen 
hierzu verschiedene Faktoren. Neben dem Alter und 
Geschlecht eines Erkrankten spielen auch das soziale 
Umfeld und Umwelteinflüsse eine Rolle. Häufungen von 
Krankheitsfällen haben immer eine räumliche und 
zeitliche Komponente. Diese Informationen sind eine 
wichtige Bewertungshilfe. 

Die Epidemiologie entwickelt mathematische Methoden und 
Modelle um die erfassten Daten zueinander in Beziehung 
zu bringen. Ein einfaches Mittel sind Kennzahlen. Diese 
helfen einem Beobachter dabei, aufgetretene Fälle 
objektiver zu beurteilen.

2.1.1 Epidemiologische Kennzahlen und Definitionen

 Prävalenz

Diese Größe gibt die Anzahl der Erkrankungsfälle in 
einer Population an. Sie berechnet sich mit \frac{Anzahl\, der\, Erkrankten}{Anzahl\, der\, Mitglieder\, einer\, Population}.

 Inzidenz 

Dieser Wert bezeichnet die Anzahl der Neuerkrankungen 
einer Population während eines bestimmten Zeitraumes. 
Die Jahresinzidenz bezieht sich dabei üblicherweise auf 
100.000 Einwohner. Anhand der Inzidenz lässt sich die 
Rate der Neuerkrankungen in einem Gebiet unabhängig von 
der Bevölkerungsdichte betrachten. In Ballungszentren 
gibt es immer mehr Fälle als in einem kleinen Dorf. 
Diese Kennzahl schafft die Vergleichbarkeit zwischen 
einer Großstadt und einer 1000-Seelen-Gemeinde. Bei 
Krankheiten mit einer langen Erkrankungsdauer ist die 
Inzidenz niedriger als die Prävalenz.

 Cluster

Dieser Begriff bezeichnet in der Epidemiologie eine 
zeitlich und örtlich verstärkt auftretende Häufungen 
von Erkrankungen des gleichen Typs. 

2.1.2 <sub:Epidemiologie-in-Deutschland>Epidemiologie in Deutschland

Das Infektionsschutzgesetz (IfSG) [ifsg:2000] regelt in 
Deutschland die Zusammenarbeit von Behörden des Bundes, 
der Länder und der Kommunen, Ärzten, Tierärzten, 
Krankenhäusern, wissenschaftlichen Einrichtungen sowie 
sonstigen Beteiligten in allen Bereichen der 
Epidemiologie. Abschnitt 3 dieses Gesetzes beschreibt 
das Meldewesen. Abbildung [fig:Meldewege] gibt einen Überblick. 

<Grafikdatei: figures/meldewege.eps>


<fig:Meldewege>Erfassung von Infektionserkrankungen in Deutschland.

Feststellende Ärzte, Krankenhäuser und anderen Personensiehe auch IfSG § 8 Zur Meldung verpflichtete Personen 
müssen meldepflichtige Krankheitensiehe auch IfSG § 6 Meldepflichtige Krankheiten bzw. Nachweise von 
Krankheitserregernsiehe auch IfSG § 7 Meldepflichtige Nachweise von 
Krankheitserregern
 an das zuständige Gesundheitsamt übermitteln. Dieses 
erhält auch personenbezogene Patientendatensiehe auch IfSG § 9 Namentliche Meldung. Das Amt 
muss die gesammelten Daten in anonymisierter Formsiehe auch IfSG § 10 Nichtnamentliche Meldung an 
die zuständige Landesbehörde meldensiehe auch IfSG § 11 Übermittlungen durch das 
Gesundheitsamt und die zuständige Landesbehörde
. Die für Bayern zuständige Behörde ist beispielsweise 
das Bayerisches Landesamt für Gesundheit und 
Lebensmittelsicherheit (LGL).

Die zentrale Einrichtung der Bundesregierung auf dem 
Gebiet der Krankheitsüberwachung und -prävention ist 
das Robert Koch-Institut (RKI). Die Länder übermitteln 
dieser Behörde laufend die aktuellen Erkrankungsdaten 
(in der vorliegenden nichtnamentlichen Form). Nach dem 
IfSG hat das RKI folgende Aufgabensiehe auch IfSG § 4 Aufgaben des Robert Koch-Institutes:

Entwicklung von "Konzeptionen zur Vorbeugung 
übertragbarer Krankheiten sowie zur frühzeitigen 
Erkennung und Verhinderung der Weiterverbreitung von 
Infektionen. Dies schließt die Entwicklung und 
Durchführung epidemiologischer und laborgestützter 
Analysen sowie Forschung zu Ursache, Diagnostik und 
Prävention übertragbarer Krankheiten ein."

Das Robert Koch-Institut

* "erstellt [...] Richtlinien, Empfehlungen, Merkblätter 
  und sonstige Informationen zur Vorbeugung, Erkennung 
  und Verhinderung der Weiterverbreitung übertragbarer 
  Krankheiten",

* "hat [...] Kriterien (Falldefinitionen) für die 
  Übermittlung eines Erkrankungs- oder Todesfalls und 
  eines Nachweises von Krankheitserregern zu erstellen",

* "fasst [...] [übermittelte] Meldungen zusammen, um sie 
  infektionsepidemiologisch auszuwerten",

* veröffentlicht regelmäßig "die Zusammenfassungen und 
  die Ergebnisse der infektionsepidemiologischen Auswertungen"

Das RKI benennt seit 1995 bei besonders wichtigen 
übertragbaren Krankheitserregern wie Mycobacterium 
tuberculosis, Meningokokken oder Salmonellen Nationale 
Referenzzentren (NRZ) zu deren Überwachung [rki_nrz:05]. Die 
Berufung erfolgt durch das Bundesministerium für 
Gesundheit und Soziale Sicherung (BMGS) für jeweils 
drei Jahre. 

Diese Zentren haben unter anderem Beratungsaufgaben, 
erstellen Gutachten und führen Laboruntersuchungen von 
Erkrankungsfällen durch. Sie übernehmen Aufgaben in der 
Qualitätssicherung und kooperieren mit dem RKI und 
internationalen Organisationen. Das RKI empfiehlt 
Krankenhäusern und Primärlaboratorien diese 
Dienstleistungen in Anspruch zu nehmen und entnommene 
Proben von Patienten an das entsprechende 
Referenzzentrum zu schicken.

2.1.3 Meningokokken

Einer der übertragbaren Krankheitserreger des Menschen, 
denen großes öffentliches Interesse zukommt, sind die 
Meningokokkenwissenschaftlicher Name: Neisseria meningitidis. Es handelt sich hierbei um gramnegative 
Bakterien, die in 12 verschiedene Serogruppen 
unterteilt werden. Die Mikrobiologie teilt Variationen 
von Bakterien oder Viren anhand von Merkmalen auf deren 
Oberfläche in so genannte Serogruppen, Serotypen oder 
Serovare ein, wenn sie diese mit spezifischen 
Antikörpern unterscheiden kann. In Deutschland kommen 
von diesen seit Jahren fast ausschließlich die 
Serogruppe B und C vor. Altersabhängig besiedeln die 
Bakterien bei bis zu über 30% der Gesunden die 
Schleimhäute im Nasen-Rachenraum [epibul34:05], führen dabei jedoch 
in den wenigsten Fällen zu einer Erkrankung.

Die Jahresinzidenz lag 2003 in Deutschland bei ca. 1,1 
Fällen pro 100.000 Einwohner [schrauder:2005]. Im Jahr 2004 sind 
insgesamt 603 Fälle von Meningokokkenerkrankungen 
gemeldet worden. Zu den verursachten Krankheiten zählen 
Hirnhautentzündung und Blutvergiftung (Sepsis). 5-10% 
der Erkrankungsfälle enden tödlich.

Säuglinge und Kleinkinder bis zwei Jahren sind am 
häufigsten von der Krankheit betroffen. Gegen die 
häufige Serogruppe B gibt es bis heute noch keinen 
generell verfügbaren Impfstoff. Die Krankheit kann in 
Einzelfällen von den ersten Anzeichen bis zum Tod 
innerhalb eines Tages verlaufen. Diese Tatsachen 
erfordern bei Meningokokken trotz der geringen Inzidenz 
eine sorgfältige Überwachung.

2.1.4 Arbeit des Nationalen Referenzzentrums für Meningokokken

Das Nationale Referenzzentrum für Meningokokken (NRZM) 
überwacht im Auftrag des Robert Koch-Instituts 
Meningokokkenerkrankungen in Deutschland. Es erfüllt 
die unter [sub:Epidemiologie-in-Deutschland] angegebenen Aufgaben. Dazu gehört ein großes 
Leistungsangebot in der molekularen Epidemiologie. Zwei 
Bereiche aus der Arbeit des Referenzzentrums werden im 
Folgenden näher beschrieben.

 Typisierung von Meningokokken-Erkrankungsfällen

Das NRZM führt mehrere verschiedene Typisierungsarten 
bei eingesandten Meningokokkenstämmen durch:

* serologische Typisierung
  Bestimmung der Serogruppe (definiert durch die 
  Zuckerreste der Polysaccharidkapsel).

* molekularbiologische Typisierung

  * mittels PorA- und FetA-Sequenzierung 
    Typisierungsverfahren, das zunehmend für die 
    serologische Bestimmung von einem Serotyp und 
    Serosubtyp eingesetzt wird. Diese Werte erlauben 
    eine viel feinere Typisierung als die Serogruppe alleine.

  * mittels Multi-Locus-Sequenz-Typisierung (MLST) 
    ausgewählter Isolate

Die Mitarbeiter des Referenzzentrums bestimmen mittels 
der PorA- und FetA-Squenzierung einen genauen Typ für 
jede eingesandte Probe. Die Nomenklatur benennt diesen 
mit der Zeichenkette {Serogruppe}:P1.{PorA}:F{FetA}. 
Der so genannte Feintyp identifiziert einen bestimmten 
Meningokokkenerreger eindeutig. Die Feintypisierung 
hilft unter anderem bei folgenden Aufgaben:

* Erfassung der epidemiologischen Dynamik auf 
  nationaler und internationaler Ebene
  Meningokokken verändern sich nur marginal bei einer 
  Übertragung von Mensch zu Mensch. Wenn sich Person A 
  an Person B ansteckt, tragen beide den selben Feintyp 
  in sich. Hierdurch ist es möglich, dass einzelne 
  Feintypen zu einem Zeitpunkt örtlich verstärkt 
  auftreten oder komplett verschwinden.

* Analyse von epidemiologisch verknüpften Fällen 
  (Ausbruchsanalyse)
  Person A und B werden aufgrund eines Verdachts auf 
  Meningokokken-Meningitis zur stationären Behandlung 
  in ein Kreiskrankenhaus eingewiesen. Dort entnommene 
  Proben werden an das NRZM geschickt um anhand des 
  Feintyps feststellen zu lassen, ob die beiden Fälle 
  in einem Zusammenhang stehen.

* Ermittlung von Daten für die Entwicklung von Impfstoffen
  Die Hersteller von Impfstoffen benötigen genaue 
  Informationen über die Oberflächenproteine eines 
  Erregers. Die Feintypisierung liefert dieses Wissen.

 Computergestützte Clusteridentifizierung am NRZM

Die Epidemiologen des Referenzzentrums nutzen die 
Feintypisierungsergebnisse zu weiteren statistischen 
Analysen. Bei der computergestützten 
Clusteridentifizierung handelt es sich um ein 
Verfahren, das mittels einer von Kulldorff et al. [kulldorff:1997] 
entwickelten Software durchgeführt wird. Das Programm 
SaTScan [kulldorff_satscan:2005] kann anhand der spatio-temporalenraum-zeitlichen 
Informationen von Ereignissen erkennen, ob diese in 
einem Zusammenhang stehen (siehe [sec:Identifizierung-von-Clustern]). 

Bezogen auf die Feintypen erkennt die 
Clusteridentifizierung, im Gegensatz zu der im 
vorherigen Abschnitt genannten Ausbruchsanalyse, 
selbstständig zusammengehörige Fälle eines Feintyps. 
Das NRZM entdeckt damit frühzeitig potenzielle 
Ausbrüche von Meningokokken-Erkrankungen. Anhand dieser 
Information sind die Landesbehörden und das Robert 
Koch-Institut in der Lage, z.B. Impfempfehlungen für 
die betroffenen Landkreise auszusprechen.

 Informationsfluss und Arbeitsabläufe

Der Informationsfluss und die Arbeitsabläufe im NRZM 
sind in Abbildung [fig:Informationsfluss-im-NRZM] schematisch dargestellt. 

1. Ein Krankenhaus oder Primärlabor schickt eine Probe 
  an das Referenzzentrum.

2. Ein Mitarbeiter erfasst die Probe mit Eingangsdatum 
  und weiteren Patientendaten (u.a. Alter, Initialen, 
  Wohnort) in einer Access-Datenbank.

3. Das Labor führt die oben genannten 
  Typisierungsmethoden durch. Der Datenbankeintrag 
  einer Probe wird um den Feintyp ergänzt.

4. Das Referenzzentrum schickt einen Befund mit allen 
  Informationen zu dem gefundenen Meningokokken-Stamm 
  an den Auftraggeber und das zuständige Gesundheitsamt.

5. Die Epidemiologen führen spatio-temporale 
  Clusteridentifizierungen auf Basis der gefundenen 
  Feintypen durch und

6. erzeugen mit RegiographDesktop GIS-Anwendung von der Firma GfK MACON Clusterkarten.

7. Das RKI erhält diese Karten zusammen mit einem 
  Clusterbericht und stimmt evtl. zu treffende 
  Maßnahmen mit den Landesbehörden und dem 
  Gesundheitsamt ab.

<Grafikdatei: figures/nrzm_ablauf_alt.eps>


<fig:Informationsfluss-im-NRZM>Bisheriger Informationsfluss bei der Typisierung von 
eingesandten Proben im NRZM

2.2 Geografische Informationssysteme

  Definition

Ein Geografisches Informationssystem (GIS) ist ein 
Computersystem (Hard- und Software). Es hilft dem 
Benutzer dabei, Daten mit räumlichem Bezug zu verwalten 
und zueinander in Beziehung zu setzten. GIS kann als 
eine Art von räumlichem Entscheidungsfindungssystem 
beschrieben werden. (Heywood at al. [heywood:99])

Das erste landesweite Geoinformationssystem hat die 
Firma ESRIEnvironmental Systems Research Institute 1973 [gss07:05] unter dem Titel "The Maryland Automated 
Geographic System" erstellt. Seit dem gewinnt GIS in 
vielen Behörden, Firmen und auch bei Privatpersonen 
immer mehr an Bedeutung. 

So hat zum Beispiel die Gemeinde Oerlenbach bei Bad 
Kissingen im Jahr 2005 eine gesplittete Abwassergebühr 
eingeführt. Mitarbeiter teilen mittels Orthofotosverzerrungsfreie und maßstabsgetreue Luftbildaufnahmen und 
einer GIS-Software alle Grundstücke der Gemeinde in die 
verschiedenen Versiegelungsarten (Dachflächen, 
Betonflächen, Hofpflaster, etc.) auf. Die 
Abwassergebühr errechnet sich u.a. nach dem 
Versiegelungsgrad und somit nach der Menge von 
Regenwasser, das in die Kanalisation gelangt. Ohne die 
Hilfe eines Geoinformationssystems wäre diese, per 
Gerichtsurteil vorgeschriebene, Maßnahme mit erheblich 
mehr Aufwand verbunden gewesen.

2.2.1 Räumliches Datenmodell

Der Benutzer eines Geoinformationssystems möchte 
bestimmte Bereiche der Realität modellieren. Das Modell 
soll so einfach wie möglich und so komplex wie nötig 
sein. GI-Systeme wandeln mit verschiedenen Methoden die 
vorhandenen Daten in digitale Karten um. 

 <sub:Grundlegende-Geo-Komponenten>Grundlegende Komponenten zur Abbildung der Realität

GI-Systeme bilden die Realität mittels einfacher 
geometrischer Elemente ab:

* Punkte
  Punkte werden, abhängig von dem benötigten Detailgrad 
  der Karte, für unterschiedliche Informationen 
  eingesetzt. Ein Stadtplan verwendet sie 
  beispielsweise, um die Position einer 
  Touristeninformation zu markieren. Auf Landkarten 
  können andererseits ganze Städte nur anhand ihrer 
  Mittelpunktkoordinaten platziert sein. 

* Linien
  Linien repräsentieren eine geordnete Menge von 
  Punkten. Flüsse oder Straßen sind in GI-Systemen oft 
  in dieser Form gespeichert.

* Flächen
  Flächen können zum Beispiel Landesgrenzen darstellen. 
  GI-Systeme speichern sie als Polygone. Wenn mehrere 
  Einzelflächen eine Einheit bilden (z.B. ein Staat und 
  seine Inseln), werden diese als Gruppe von Polygonen 
  (Multipolygone) gespeichert.

* Rasterdaten
  Rasterdaten sind spalten- und zeilenweise in einzelne 
  Bildpunkte aufgeteilte Vektordaten. Im Vergleich zu 
  den obigen punktgenauen geometrischen Daten gehen 
  Informationen verloren (siehe Abbildung [fig:Polygons-vs-Raster]). Eine 
  nützliche Einsatzmöglichkeit von Rasterdaten in 
  Geoinformationssystemen sind Luft- oder 
  Satellitenbilder. 

<Grafikdatei: figures/vektor_vs_raster.eps>


<fig:Polygons-vs-Raster>Vergleich eines Polygons in Vektor- und Rasterdarstellung

2.2.2 Koordinaten und Kartenprojektionen

Jeder Punkt auf der Erdoberfläche und somit jede 
Koordinate in einem GIS ist exakt durch die 
geografische Länge und Breite definiert. Die Erde ist 
in 360 Längenkreise und 180 Breitenkreise aufgeteilt. 
Die Länge definiert sich dabei als Winkelmaß bis je 
180° östlich (E) oder westlich (W) des Nullmeridians, 
der durch die Sternwarte von Greenwich verläuft. Die 
Breite als solches bis je 90° nördlich (N) oder südlich 
(S) des Äquators. Eine bestimmte Position auf dem 
Globus lässt sich am einfachsten mit Hilfe von 
geografischen Koordinaten beschreiben.

GI-Systeme stehen vor der Aufgabe, die gekrümmte 
Erdoberfläche auf eine flache Karte zu übertragen 
(Kartenprojektion). Dieser Vorgang lässt sich nach 
Heywood at al. am einfachsten folgendermaßen 
veranschaulichen: 

Ein Globus ist am Nordpol an der Decke eines Raumes 
aufgehängt und von innen beleuchtet. Das Licht 
projiziert ein Bild der Erdoberfläche auf die Wände. 
Das Experiment wird mit drei verschiedenen Räumen 
durchgeführt. Einer ist quadratisch (flache Wände), 
einer zylinderförmig (runde Wände) und der dritte 
kegelförmig (vergleichbar mit einem Tipi). Die Wände 
lassen sich theoretisch auf eine Fläche ausbreiten. Die 
resultierenden Karten haben, abhängig vom der Form des 
Raumes, verschiedene Eigenschaften (siehe Abbildung [fig:Projektionen]).

 Vergleich der grundlegenden Kartenprojektionen

* Zylinderprojektion

  * kontinuierliche Abbildung der Erde

  * die dem Zylinder am nächsten liegenden Punkte 
    werden unverzerrt abgebildet

  * gut geeignet, um Karten von kleinen Gebieten zu erzeugen

  * Flächen bleiben weitgehend erhalten

* Azimutalprojektion (Ebene)

  * nur ein Teil der Erdoberfläche (maximal die Hälfte) 
    ist sichtbar

  * Verzerrungen an allen vier Seiten

  * Abstände bleiben weitgehend erhalten

* Kegelprojektion

  * Flächen stimmen nicht mehr überein

  * die Abstände im unteren Bereich des Bildes sind 
    stark verzerrt

  * Größenverhältnisse bleiben weitgehend erhalten

<Grafikdatei: figures/zylinderprojektion.jpg>
<Grafikdatei: figures/azimutalprojektion.jpg>
<Grafikdatei: figures/kegelprojektion.jpg>


<fig:Projektionen>Beispiele für das erzeugte Bild der Erdoberfläche bei 
einer Zylinder-, Azimutal- oder Kegelprojektion [kuehn:2005]

Viele Kartografen und Mathematiker haben sich dem Thema 
Kartenprojektion angenommen und die oben genannten 
Projektionsarten gemäß bestimmter Anforderungen umgesetzt.

 Mercator-Projektion

Diese Projektion wurde von Gerhard Mercator 1569 
vorgestellt. Sie ist winkeltreu und wird häufig zur 
Navigation in der Schifffahrt eingesetzt. Die 
Mercator-Projektion gehört zu den Zylinderprojektionen. 
Der Zylinder berührt die Erde entlang des Äquators. 
Seefahrer haben durch die Winkeltreue den Vorteil, das 
Kurse mit konstanter Richtung als gerade Linien auf der 
Karte erscheinen. Ein Nachteil dieser Projektion ist 
die starke Größenverzerrung in Richtung der Pole. 
Grönland (2,2 Mio. km²) erscheint beispielsweise in 
Abbildung [fig:Mercator-Projektion] größer als Südamerika (17,8 Mio km²).

 Traversale Mercator-Projektion

<Grafikdatei: figures/mercator.png>


<fig:Mercator-Projektion>Mercator-Projektion [kuehn:2005]
Carl Friedrich Gauß und Johann Heinrich Louis Krüger 
haben diese Projektion entwickelt. Sie wird auch als 
Gauß-Krüger-Projektion bezeichnet und ist eine 
konforme, d.h. in in kleinsten Bereichen winkeltreue, 
Abbildung. 

Im Gegensatz zur Mercatorprojektion ist der die Erde 
umgebende Zylinder hier um 90° gedreht und berührt 
somit einen Längenkreis. Weiterhin bildet Gauß-Krüger 
die Erde nicht im Ganzen, sondern streifenweise ab. 

Die Längenkreise, an denen der Zylinder die Erde 
berührt, werden Bezugsmeridiane genannt. Dort ist die 
Projektion verzerrungsfrei. Viele Koordinatensysteme 
verwenden die traversale Mercator-Projektion nach 
diesem Prinzip. Die zwei wichtigsten für Deutschland sind:

* Gauß-Krüger-Koordinatensystem
  Das Gauß-Krüger-Koordinatensystem teilt die Erde in 
  3° breite Meridianstreifen auf. Jeder Streifen wird 
  anhand seines Bezugsmeridians von eins bis sieben 
  durchnummeriert. Dieser liegt liegt genau in der 
  Mitte des Streifens. Die sieben verwendeten 
  Längenkreise sind 3°E, 6°E, 9°E, 12°E, 15°E, 18°E und 
  21°E [panitzki:05]. Dieses Koordinatensystem bildet nur ein 
  Teilgebiet der nördlichen Hemisphäre ab. Deutschland 
  setzt Gauß-Krüger seit 1927 als amtliche 
  Vermessungsmethode ein. Zur Zeit findet eine 
  Umstellung auf das UTM-System statt .

* UTM-Koordinatensystem
  UTM steht für den englischen Ausdruck "Universal 
  Transverse Mercator". Im Gegensatz zu dem 
  Gauß-Krüger-System setzt das UTM-System 6° breite 
  Meridianstreifen ein. Das ergibt bei 360 
  Längenkreisen 60 Bezugsmeridiane. Diese überspannen 
  in der geografischen Breite ein Gebiet von 80°S bis 
  84°N. Bis auf die Polregionen wird die ganze Welt 
  abgedeckt. Jeder Bezugsmeridian wird wieder 
  nummeriert (Zone). Deutschland liegt in den Zonen 32 
  und 33.

Durch die Verwendung von Koordinatensystemen lassen 
sich Punkte auf der Erdoberfläche in einem 
rechtwinkligem Gitter markieren. Dies erleichtert, im 
Gegensatz zu den geografischen Koordinaten, das 
Eintragen und Ausmessen von Positionen.

2.2.3 Topologie

Topologie beschreibt die Beziehung von geometrischen 
Informationen zueinander. Diese ist - unabhängig vom 
Koordinatensystem - immer gleich. Folgende Beispiele 
sind topologische Fakten:

* Würzburg liegt in Unterfranken

* Unterfranken liegt in Bayern

* Hessen grenzt an Unterfranken

* Der Main mündet in den Rhein (ist mit ihm verbunden)

* Berlin liegt nicht in Bayern

Topologie spielt in GIS eine große Rolle. Viele Fragen 
lassen sich nur mit Hilfe dieser Beziehungen 
beantworten. Routenplanung wäre zum Beispiel unmöglich, 
wenn das System nicht erkennen könnte, welche Straßen 
miteinander verbunden sind.

2.2.4 <sec:Identifizierung-von-Clustern>Einsatz von Geoinformationen und Statistik in der 
  Epidemiologie

Für die Epidemiologie sind Ort und Zeit neben den Daten 
zu dem Krankheitserrerger die wichtigsten 
Zusatzinformationen zur Aufdeckung von 
Gesundheitsproblemen in der Bevölkerung. Oftmals werden 
für diese Arbeit desktop-basierte GIS-Applikationen verwendet.

Chung et al. untersuchten inwieweit GI-Systeme in 
Verbindung mit statistischer Datenanalyse in Studien 
der Epidemiologie und des öffentlichen 
Gesundheitswesens Anwendung finden [chung:2004]. 

Die Hauptaufgabe der Geoinformationssysteme ist dabei 
die Visualisierung der Ergebnisse. Die statistische 
Analyse führen oft eigenständige außerhalb des 
GI-Systems stehenden Werkzeuge durch. 

 Räumliche Analysen

Die räumliche Analyse nutzt zur Bewertung von 
Gesundheitsrisiken ganz normale GIS-Operationen. Diese 
führen beispielsweise auf der Topologie basierende 
Abfragen durch. Der Anwender muss das Ergebnis selbst bewerten.

Eine bei Chung et al. genannte Studie führt 
beispielsweise mittels einer auf Verkehrswege 
spezialisierten GIS-Software die Analyse der Zeiten für 
Krankentransporte durch. Sie errechnet mittels GIS den 
schnellsten Weg von allen Städten zum nächsten 
Krankenhaus. Anhand dieser Zeiten schätzt eine separate 
Statistiksoftware u.a. die Wahrscheinlichkeit für das 
Versterben eines Patienten im Krankenhaus ab.

 Visalisierung von räumlicher Unsicherheit

Insbesondere bei der Darstellung von Punktdaten in 
einem GIS gehen bestimmte Informationen verloren. Durch 
die Auflösung der Datenerhebung (Postleitzahlen) wird 
beispielsweise die Position eines Erkrankungsfalles 
genau auf eine Koordinate diskretisiert.

So genannten "kernel-density maps" erlauben eine bessere 
Darstellung dieser diskreten Daten, indem 
Punktinformationen in unregelmäßige Flächen umgewandelt 
werden. Deren Form und Einfärbung wird durch die 
Nachbarschaften und Dichte der Punkte in einem Bereich 
beeinflusst. 

Diese Art der Darstellung zieht damit die Unsicherheit 
mit in Betracht, dass ein Erkrankungsfall 
beispielsweise in einer Stadt nicht genau an der 
geografischen Länge und Breite deren Zentrums 
aufgetreten ist. Norström et al. visualisieren mittels 
dieser "kernel-density maps" die Entwicklung eines 
Erkrankungsausbruchs unter norwegischen Rinderherden [nordstrom:2000]. 
Die Karten von aufeinender folgenden Zeiträumen zeigen 
dabei sehr anschaulich, wie sich das Zentrum der 
Krankheit über administrative Grenzen hinweg "bewegt".

 Clusteridentifizierung mit der räumlichen "Scan Statistic"
   nach Kulldorff

Die Methode der räumlichen "Scan Statistic" von Kulldorff [kulldorff:1997]
 kann feststellen, ob Häufungen von punktuellen 
Ereignissen durch Zufall verursacht sind oder nich. 

Dazu stellt sie die maximale Anzahl von Ereignissen 
fest, die in einem über die Karte bewegten räumlichen 
Fenster variabler Größe (nach oben begrenzt) liegen. 
Das in der Epidemiologie eingesetzte keisförmiges 
Fenster nimmt hier nur Positionen ein, die vorher 
definiert wurden und von denen die Bevölkerungsdaten 
bekannt sind. Das sind beispielsweise die Zentren von 
Landkreisen.

Für die Fallverteilung im Fenster mit der maximalen 
Anzahl wird die Nullhypothese aufgestellt, dass die 
Zahl der Fälle einer bestimmten 
Wahrscheinlichkeitsverteilung folgt 
(Monte-Carlo-Methode). Der aus einer mehrere 
Wiederholungen dieses Versuchs hervorgehende P-Wert 
drückt letztlich die Wahrscheinlichkeit aus, dass die 
beobachtete Verteilung von Ereignissen reiner Zufall 
war. 

Kann beispielsweise bei 999 Wiederholungen nur einmal 
die vorgefundene geografische Konstellation von 
Erkrankungsfällen mittels einer Poisson-Verteilung 
angenähert werden, beträgt der P-Wert 0,001. Die 
beobachteten Ereignisse sind also nur mit einer 
Wahrscheinlichkeit von einem Promille durch Zufall 
entstanden. Die Methode von Kulldorff hat somit einen 
sehr wahrscheinlichen räumlichen Cluster entdeckt.

 Clusteridentifizierung mit der spatio-temporalen "Scan Statistic"
   nach Kulldorff

Die Epidemiologie nutzt zur Identifizierung von 
Clustern oft nicht nur die räumliche, sondern auch die 
zeitliche Dimension. Kulldorff hat auch für diese 
Aufgabe eine statistische Methode entwickelt [kulldorff:2001].

Das Grundprinzip gleicht dem der räumlichen "Scan Statistic"
. Allerdings handelt es sich bei dem bewegten Fenster 
nicht um einen zweidimensionalen Kreis, sondern um 
einen Zylinder. Die dritte Dimension drückt dabei aus, 
welche Zeit zwischen zwei Ereignissen liegt. Durch 
Kombination aller möglichen Kreisradien und 
Zylinderhöhen stellt die Methode fest, ob irgend eine 
Konstellation aufgetreten ist, die mit bestimmter 
Sicherheit kein Zufall sein könnte.

Ein erfolgreicher Fund bezeichnet dann einen 
spation-temporalen Cluster. Dieser hat eine bestimmte 
Ausdehnung (Radius) und ein Start- und Enddatum.



<cha:Definition-der-Anforderungen>Definition der Anforderungen

Das vorliegende Kapitel gibt das mit dem Nationalen 
Referenzzentrum für Meningokokken und der Firma Ridom 
GmbH abgestimmte Pflichtenheft wieder. Es behandelt 
alle Kriterien, die das Software-System erfüllen muss, 
die Einsatzbereiche, Daten, Funktionen und weitere 
Anforderungen. Das System ist während der Entwicklung 
auf zwei getrennte Rechner aufgeteilt. Diese werden im 
Folgenden als Daten-/Kartenserver und Webserver 
unterschieden. 

Der Daten- und Kartenserver speichert alle Daten und 
führt die GIS-spezifischen Aufgaben, wie z.B. die 
Kartenerzeugung aus. Der Webserver liefert die Website 
und damit vorrangig den Kartenbetrachter an den Benutzer.

3.1 Zielbestimmungen 

3.1.1 Musskriterien

 Datenbankschnittstelle zur Entgegennahme von Meldedaten

Die von den Laboratorien erzeugten Daten müssen auf den 
Daten-Server übertragen werden. Das Labor schickt die 
Typisierungsdaten in einem vereinbartem Format an den 
Server. Auf diesem läuft eine Anwendung, die als 
Schnittstelle zu dem Labor dient. Sie stimmt die 
ankommenden Daten auf das einheitliche interne 
Datenbankformat ab. Hierdurch werden die Daten 
frühzeitig in eine normierte Form gebracht die es 
erlaubt, das Programm einfach an andere Laboratorien 
oder Krankheitserreger anzupassen.

 Webserver mit JSP

Die Website, die dem Benutzer die Daten präsentiert, 
wird dynamisch mit JavaServer Pages (JSP) generiert. 
Das Interface sollte leicht zu erfassen sein.

 Datenschutz auf dem Webserver

Aus Gründen des Datenschutzes muss auf dem Webserver 
eine Zugriffsregelung möglich sein. Von Seiten des RKI 
bedeutet Datenschutz, dass es nicht möglich sein darf 
weniger als vier komplett typisierte Erkrankungen zu 
einem Landkreis zuordnen zu können. Die öffentlich 
zugänglichen Bereiche müssen so ausgelegt sein, das 
diese Vorgabe immer erfüllt ist.

 Dynamische serverseitige Erzeugung von Karten

Auf dem GIS-Server läuft eine Kartenserver-Applikation, 
die auf Anfrage des Webserver dynamisch 
epidemiologische Karten in Form von Bilddateien 
generiert. Das soll für verschiedene Auflösungen (z.B. 
Landkreis, Bundesland etc.) geschehen. Die zugrunde 
liegenden geografischen Daten sind in der Datenbank gespeichert.

 Statistische Analyse

Zur Clusterdetektion muss auf dem GIS-Server eine 
statistische Analyse der gemeldeten Erkrankungsfälle 
durchgeführt werden. Das Labor muss grundlegende 
Parameter dieser Analyse anpassen können.

3.1.2 Wunschkriterien 

 Keine festgelegten Auflösungsebenen

Um das Produkt so universell wie möglich zu halten, 
wäre es wünschenswert, die unterschiedlichen 
Kartenauflösungen nicht an speziellen Informationen wie 
z.B. Kreisnummern oder Bundesländern zu verankern. Bei 
einem Einsatz in Kliniken sind z.B. kleinere Gebiete 
wie Gebäude und Abteilungen relevant. Daher ist es 
besser, mit Koordinaten und universellen Hierarchien zu arbeiten.

3.1.3 Abgrenzungskriterien

Bei der Software handelt es sich um ein System zur 
Entscheidungshilfe. Sie hat nicht zum Ziel eine 
künstliche Intelligenz zu integrieren, die eigenmächtig 
die Signifikanz der erfassten Daten bewertet. Das 
Hauptziel liegt vielmehr in der Kombination aller 
nötigen Komponenten zu einem homogenen und benutzbaren 
Gesamtsystem.

3.2 Produkt-Einsatz

3.2.1 Anwendungsbereiche

Der Anwender möchte mit dem Produkt eine automatisierte 
Analyse der spatio-temporalen Daten durchführen. Die 
einzige Anforderung an die Daten ist daher, dass sie 
eine zeitliche und örtliche Komponente haben und sich 
verschiedene Ereignisse unterscheiden lassen. Ein 
Webserver soll die Ergebnisse der Analysen einer breit 
gefächerten Personengruppe zugänglich machen.

3.2.2 Zielgruppen

  "Käufer"-Zielgruppen

des Systems sind auf nationaler Ebene Referenzzentren 
(speziell das NRZM), Länder bzw. 
Bundesgesundheitsbehörden (z.B. RKI), Krankenhäuser 
oder Militär. Auch supranationale Behörden wie das ECDCEuropean Centre for Disease Prevention and Control 
gehören zu den potentiellen Zielgruppen. Das System ist 
daher gänzlich in Englisch zu realisieren.

  Benutzer-Zielgruppen 

sind die interessierte Öffentlichkeit, (politische) 
Entscheidungsträger und die Vertreter des öffentlichen 
Gesundheitsdienstes (Gesundheitsämter und RKI).

3.2.3 Betriebsbedingungen

Das Produkt wird komplett serverseitig realisiert und 
daher nur über die Weboberfläche bedient. Diese soll 
rund um die Uhr erreichbar sein.

3.3 Produktfunktionen

  /F10/ Datenbankmodell zur Speicherung 
  epidemiologischer Daten

  Es wird ein Datenbankmodell benötigt, welches so 
  generisch wie möglich gestaltet ist. Ziel hiervon ist 
  es, das Produkt mit möglichst geringen Anpassungen 
  auch für die epidemiologischen Daten anderer 
  Erkrankungen nutzen zu können.

  /F11/ Entgegennahme von Typisierungs-Ergebnisdaten

  Die vom Benutzer erzeugten Typisierungs-Ergebnisdaten 
  müssen über eine Schnittstelle entgegen genommen 
  werden. Hierbei ist darauf zu achten, dass ein 
  proprietäres Datenbankformat wie beispielsweise 
  Access auf die interne PostgreSQL Datenbank 
  abgebildet wird. Das NRZM überträgt die Daten mittels 
  einer CSVCharacter Separated Values bzw. Comma Separated Values Datei. Unter Linux lassen sich Access 
  Datenquellen nicht direkt nutzen.

  /F12/ Datenschutzaspekte

  Neben dem sicheren Transfer der Daten zum Server muss 
  auch gewährleistet sein, dass die Datenbank vor 
  unberechtigtem Zugriff ausreichend geschützt ist.

  /F20/ Universeller GIS-Service für epidemiologische Daten

  Auf Grundlage der Typisierungsergebnisse wird ein 
  GIS-Service entwickelt, welcher die epidemiologischen 
  Daten (Person, Ort, Zeit, (Sub)Typen) auf Landkarten 
  visualisiert. Hierbei ist es wichtig, dass Karten mit 
  verschiedenen Detailgraden (5-stellige PLZ, Kreis, 
  Bundesland, Land) angezeigt werden können.

  /F21/ Webservice zur Präsentation des Kartenmaterials

    Eine Flash-Anwendung präsentiert den Benutzern die 
    erzeugten Landkarten. Sie muss klar gestaltet sein, 
    damit die Informationen leicht zugänglich sind.

  /F22/ Kartenarten

    Es werden verschiedene Arten von Karten benötigt. 
    Um die Inzidenz für einzelne Bereiche darzustellen, 
    sollen diese eingefärbt werden. Für Punktereignisse 
    (Einzelfälle) werden verschiedene Symbole (z.B. 
    Kreis, Dreieck, Stern) in unterschiedlichen Farben verwendet.

    Es wäre wünschenswert, Einzelfällen ähnlich wie bei 
    der Arbeitsgemeinschaft Influenza [agi:05] darzustellen.

  /F30/ Durchführung der spatio-temporalen Analyse mit SaTScan

  SaTScan wird als Werkzeug aus Java heraus aufgerufen. 
  Es benötigt verschiedene Dateien als Eingabe und 
  schreibt die Ergebnisse in Ausgabedateien. Das 
  Dateiformat ist vorgegeben.

  /F31/ Erstellung von Falldaten zur Übergabe an SaTScan

    Über Abfragen aus der Datenbank werden mittels Java 
    die von SaTScan benötigten Falldateien erstellt. 
    Bei diesen handelt es sich um Textdateien, welche 
    folgende Informationen über aufgetretene Fälle enthalten:

    * location id 
      eine eindeutige Zahl oder zusammenhängende 
      Zeichenkette, die einen Ort kennzeichnet

    * #cases
      die Anzahl der Fälle, welche zur angegebenen Zeit 
      an diesem Ort aufgetreten sind

    * time (optional)
      eine Zeitangabe in Jahren, Monaten oder Tagen

    * covariates (optional)
      beliebige Menge an Zusatzwerten, welche die 
      erfassten Fälle näher spezifizieren (z.B. 
      männlich oder weiblich)

    Bei den Meningokokken-Daten des NRZM muss für jeden 
    Feintyp eine Falldatei erstellt werden. SaTScan 
    bearbeitet jede dieser Dateien einzeln und erzeugt 
    jeweils Ergebnisdateien.

  /F32/ Integration der SaTScan Ergebnisse in die Datenbank

    Die Ergebnisdateien enthalten verschiedene 
    berechnete Werte. Diese müssen eingelesen und in 
    die Datenbank geschrieben werden. Ein mögliches 
    Ausgabeformat von SaTScan sind durch Leerzeichen 
    getrennte Werte, diese ist am besten für die 
    Weiterverarbeitung geeignet.

    Listing [lst:satscan_out] zeigt an einem Beispiel das kommentierte 
    Format anhand dem ersichtlich ist, welche Werte von 
    SaTScan berechnet werden.

  /F33/W Konfiguration der SaTScan Parameter über eine 
    Webschnittstelle

    In der Parameterdatei von SaTScan lassen sich alle 
    Optionen der Analyse anpassen. Die wichtigsten 
    Parameter sollten sich über ein Web-Interface 
    verändern lassen.

  /F40/ Ausgabe der Ergebnisse der spatio-temporalen Analyse

  Die Ergebnisse der Analysen von SaTScan werden mit 
  Hilfe der GIS-Komponente auf Landkarten angezeigt. 
  Insbesondere muss es möglich sein, die Position und 
  geografische Ausdehnung von Clustern zu erkennen und 
  über eine Zeitspanne zu verfolgen.

  /F41/W Animationen zur Darstellung von zeitlichen Verläufen

    Eine mögliche Art der Präsentation von zeitlichen 
    Entwicklungen der Fallzahlen und Clusterpositionen 
    sind Animationen. Diese könnten direkt in Flash 
    dargestellt werden.

  /F50/ Errechnung und geografische Visualisierung von Inzidenzen

  Inzidenzen haben eine besondere Bedeutung bei der 
  epidemiologischen Beobachtung. Bei dieser Analyse 
  sind größere geografische Regionen interessant (in 
  Deutschland z.B. Landkreise und Bundesländer). Die 
  Inzidenz soll dynamisch anhand der vorhandenen Fälle 
  errechnet werden.

  /F60/W Dynamische Durchführung anderer, von SaTScan 
  unabhängigen, Abfragen

  Neben dem Kartenmaterial sollten auch herkömmliche 
  Statistiken in Form von Kreuztabellen auf dem 
  Webserver präsentiert werden. Die folgenden Abfragen 
  werden vom NRZM bisher durchgeführt:

  * Feintypverteilung in Deutschland bzw. einzelnen Bundesländern

  * Serogruppenverteilung nach Bundesländern bzw. Alter

  * Häufigste Feintypen nach Alter

  * Inzidenztabellen 

  /F70/ Alle Daten werden fortschreitend jährliche 
  zusammengefasst

  Die SaTScan Analyse wird einmal wöchentlich 
  ausgeführt. Sie bezieht rückblickend vom aktuellen 
  Datum alle Erkrankungsfälle der letzten 100 Tage mit 
  ein. Zusätzlich erfolgt für jedes halbe Jahr eine "historische"
   Berechnung.

3.4 Produkt-Daten

3.4.1 Eingabedaten

  /D10/ epidemiologische Daten

  Die epidemiologischen Daten (Person, Ort, Zeit, 
  (Sub)Typen) und weitere untergegliederte Werte 
  (Alter, Geschlecht, Koordinate, Erkrankungsbeginn, 
  Erreger-Isolationsdatum) müssen in der Datenbank 
  abgelegt und für statistische Analysen zugänglich sein.

  /D20/ Populationsdaten

  Die Anwendung benötigt Populationsdaten um die 
  Inzidenzen in /F50/ zu berechnen und 
  spatio-temporalen Analyse durchführen zu können.

  /D30/ räumliche Daten

  PostgreSQL bietet die Möglichkeit alle grundlegenden 
  geografischen Datenformen (siehe Abschnitt [sub:Grundlegende-Geo-Komponenten]) zu speichern.

3.4.2 Ausgabedaten

  /D40/ verschiedene Karten

  Das System gibt Karten in unterschiedlicher 
  geografischer Auflösung (z.B. Kreis, Bundesland etc.) 
  aus. Epidemiologischen Daten sollen in verschiedener 
  Weise visualisiert werden (siehe /F22/). Bei den 
  Karten sind ggf. die Lizenzbestimmungen der 
  Kartenhersteller zu berücksichtigen.

  /D50/ errechnete Inzidenzen

  /D60/ alle Ergebnisse aus der statistischen Analyse 
  von SaTScan

3.5 Produkt-Leistungen

  /L10/ wöchentliche Batch-Prozessierungen der 
  spatio-temporalen Analysen

  /L20/ Die Ausgabe von dynamischen Abfrageergebnissen 
  bzw. Landkarten auf dem Webserver sollte so schnell 
  wie möglich erfolgen. 

3.6 Qualitätsanforderungen

Tabelle [tab:Geforderte-Produktqualität] definiert die Anforderungen an die 
Produktqualität in den Kategorien Funktionalität, 
Zuverlässigkeit, Benutzbarkeit, Effizienz, Änderbarkeit 
und Übertragbarkeit.

+------------------+-----------+------+---------+------------+
| Produktqualität  | sehr gut  | gut  | normal  | irrelevant |
+------------------+-----------+------+---------+------------+
+------------------+-----------+------+---------+------------+
| Funktionalität   |           |  X   |         |            |
+------------------+-----------+------+---------+------------+
| Zuverlässigkeit  |           |      |   X     |            |
+------------------+-----------+------+---------+------------+
| Benutzbarkeit    |           |  X   |         |            |
+------------------+-----------+------+---------+------------+
| Effizienz        |           |      |   X     |            |
+------------------+-----------+------+---------+------------+
| Änderbarkeit     |    X      |      |         |            |
+------------------+-----------+------+---------+------------+
| Übertragbarkeit  |    X      |      |         |            |
+------------------+-----------+------+---------+------------+


<tab:Geforderte-Produktqualität>Geforderte Produktqualität nach Kategorien

3.7 Technische Produktumgebung

Dieser Abschnitt beschreibt die technischen 
Voraussetzungen zum Einsatz des Software-Systems . Wie 
in diesem Kapitel eingangs erwähnt, wird hier zwischen 
dem Daten-/GIS-Server und Webserver unterschieden.

3.7.1 <sec:Hardware-Umgebung>Hardware-Umgebung

Es ist schwierig, die Anforderungen an die Hardware für 
die jeweiligen Server in konkreten Zahlen zu bestimmen. 
Gerade im Serverbetrieb hat die Anzahl der simultanen 
Anfragen einen entscheidenden Einfluss auf die 
benötigte Leistung bzw. Speicherausstattung. Der 
Kartenserver für die geografischen Abfragen und die 
Bilderzeugung mehr Rechenleistung als der Webserver.

Die nachfolgende Übersicht stellt aus den eben 
genannten Gründen eine Konfiguration dar, die in keiner 
Weise bindend ist:

 Daten- und Kartenserver

  Minimales System

* Prozessor der Intel Pentium/Celeron-Produktfamilie, 
  der AMD Athlon/Duron-Produktfamilie oder kompatible 
  mit 2 GHz

* 512 MB Arbeitsspeicher

  Empfohlenes System

* Prozessor der Intel Pentium/Celeron-Produktfamilie, 
  der AMD Athlon/Duron-Produktfamilie oder kompatible 
  mit 3 GHz

* 1 GB Arbeitsspeicher

 Webserver

  Minimales System

* Prozessor der Intel Pentium/Celeron-Produktfamilie, 
  der AMD Athlon/Duron-Produktfamilie oder kompatible 
  mit 800 MHz

* 256 MB Arbeitsspeicher

  Empfohlenes System

* Prozessor der Intel Pentium/Celeron-Produktfamilie, 
  der AMD Athlon/Duron-Produktfamilie oder kompatible 
  mit 2 GHz

* 512 MB Arbeitsspeicher

3.7.2 Software-Umgebung

Die Software-Umgebung bezeichnet alle auf dem 
jeweiligen Server benötigten Programme. Der folgend 
Abschnitt listet diese auf.

 Grundvoraussetzungen

Beide Server benötigen folgende Software:

* Betriebssystem Linux
  Linux bezeichnet den freien Kern eines 
  Betriebssystems. Es wurde ursprünglich von Linus 
  Torvalds entwickelt und bildet heute die Grundlage 
  für mehrere Distributionen. Die als Basissystem für  
  eingesetzte Linux-Distribution muss als einzige 
  Voraussetzung zulassen, dass sich alle benötigten 
  Softwarekomponenten installieren lassen.

* Java Runtime Environment
  Der Tomcat Webserver [tomcat:05] und alle Werkzeugprogramme von  
  sind in Java implementiert. Aus diesem Grund ist ein 
  installiertes Java Runtime Environment, Version 5.0 [java:05] 
  Grundvoraussetzung für die Serversysteme und auch den 
  Client, der die Daten überträgt.

 Daten- und Kartenserver

Für die Datenbank und Kartenerzeugung müssen folgende 
Programme installiert sein.

* GNU C Compiler (gcc) und GNU make (gmake oder make) 

* PROJ.4 Kartenprojektions-Bibliothek [proj4:05]

* GEOS geometrische Bibliothek [geos:05]

* PostgreSQL (Version 8.x) [postgresql:05]

* PostGIS für PostgreSQL [postgis:05]

* UMN MapServer (Version 4.6x) [mapserver:05]

* SaTScan (Die Entwickler verschicken eine 
  Internetadresse zum download der Linux-Version auf Anfrage.)

 Webserver

 verwendet den Apache Tomcat Servlet Container in der 
Version 5.x als Webserver. 

3.8 Entwicklungsumgebung

3.8.1 Programmiersprache

Alle Softwarekomponenten für dieses Diplomarbeit sind 
in Java realisiert. Diese von Sun entwickelte 
Programmiersprache ist mittlerweile in der Version 5.0 
verfügbar. Die Apache Software Foundation [apachesf:05] fördert mit 
vielen freien Projekten die Verwendung von Java bei der 
Softwareentwicklung. 

So stellt z.B. die durch dem Jakarta Projekt [jakarta:05] 
entwickelte Commons-Bibliothek [commons:05] eine Vielzahl von 
Java-Standardlösungen bereit [wartala:05]. Sie werden in diesem 
Projekt unter anderem für den Datenbankzugriff und die 
Ein-/Ausgabe eingesetzt.

3.8.2 Entwicklungswerkzeuge

 Integrierte Entwicklungsumgebung

Als integrierte Entwicklungsumgebung hat sich für Java 
das frei erhältliche Programm Eclipse [eclipse:05] durchgesetzt. 
Dieses plugin-basierte Softwareentwicklungs-Framework 
besteht auch den Vergleich mit kommerziellen Produkten. 
 ist mit Hilfe von Eclipse entwickelt. Dank eines 
vorgeschalteten Projektverwaltungssystems können die 
Quellen jedoch auch mit allen anderen integrierten 
Entwicklungsumgebungen bearbeitet werden. 

 Projektverwaltung

Eine Projektverwaltung vereinfacht den 
Entwicklungsprozess im Hinblick auf die Organisation 
des Quellcodes. Die Software Maven [maven:05] ist eine 
Projektverwaltung für Java-Entwickler. Sie ist 
ebenfalls aus der Jakarta-Projekt hervorgegangen und 
erleichtert den Entwicklungsprozess in mehreren 
Bereichen [maven_guide:05]:

* Der Entwicklungsvorgang (kompilieren, testen, 
  verteilen) ist standardisiert. Maven verbirgt 
  unnötige Details.

* Alle Software-Projekte sind einheitlich organisiert. 
  Ein Entwickler findet sich in unbekannten Projekten 
  schneller zurecht.

* Das System erzeugt ausführlichen Projektinformationen 
  (Changelog, Javadoc, Testergebnisse, Abhängigkeiten, 
  Metriken, etc.). 

* Maven bietet dem Entwickler eine Hilfestellung für 
  das Einhalten von bewährten Praktiken

* Externe Abhängigkeiten (Bibliotheken) lassen sich gut 
  organisieren.

Maven ist unabhängig von einer zusätzlich verwendeten 
Entwicklungsumgebung. Der Entwickler kann zum Beispiel 
die Projektdefinitionsdatei für Eclipse mit dem Befehl 
maven eclipse erzeugen lassen. Selbst umfangreiche 
Projekte mit vielen Abhängigkeiten lassen sich durch 
einen Befehl sofort in Eclipse öffnen und bearbeiten. 

Die Projektverwaltung unterstützt den Anwender auch bei 
der Versionsverwaltung. Dateien, die ein Projekt 
beschreiben liegen im XML-Format vor. Der Entwickler 
kann dadurch die Änderungen im Projekt über die 
verschiedenen Versionen hinweg leicht verfolgen. 



Untersuchung der Voraussetzungen

Dieses Kapitel dokumentiert die der Softwareentwicklung 
vorausgegangen Vorgänge. Es präsentiert Beispiele von 
bereits über das Internet zugänglichen Systemen zur 
Infektionsüberwachung. 

Weiterhin definiert es die grundlegenden Anforderungen 
für das zu entwickelnde web-basierte epidemiologische 
GIS mit integrierter Ausbruchsanalyse. Dieses stellt 
eine neuartige Kombination von Einzelkomponenten dar, 
deren Voraussetzungen näher betrachtet werden. 

Der letzte Teil diese Kapitels gibt einen Überblick 
über verfügbare Open Source Software, die sich zur 
Lösung der gegebenen Problemstellung eignet. Jedes der 
in Betracht gezogenen freien Produkte wird vorgestellt 
und hinsichtlich der Verwendbarkeit bewertet. 

4.1 <sec:Web-basierte-Systeme>Web-basierte Systeme zur Überwachung von Infektionen

Die Epidemiologen haben dank des Internets die 
Möglichkeit, die Ergebnisse ihrer Arbeit einer größeren 
Benutzerzahl zur Verfügung zu stellen. Abbildung [fig:Neuer-Informationsfluss-NRZM] 
veranschaulicht diese Möglichkeit am Beispiel des NRZM. 

<Grafikdatei: figures/nrzm_ablauf_neu.eps>


<fig:Neuer-Informationsfluss-NRZM>Neuer Informationsfluss, ermöglicht durch den Einsatz 
eines web-basierten Systems (am Beispiel des NRZM, vgl. 
Abbildung [fig:Informationsfluss-im-NRZM]) 

Ein web-basiertes Informationssystem hat neben der 
einfachen Zugänglichkeit über ein Netzwerk weitere Vorteile:

* Der Benutzer kann die angezeigten Informationen nach 
  eigenen Kriterien filtern.

* Das System kann sehr aktuell sein.

* Das Internetangebot übernimmt einen Teil der 
  Öffentlichkeitsarbeit durch Bereitstellung von Informationen.

Im weltweiten Datennetz finden sich viele solcher 
epidemiologischer Informationsportale. Die oft auf 
Landesebene eingesetzten Webangebote sind von 
unterschiedlicher Komplexität. Manche bieten nur eine 
Zusammenfassung von Statistiken in Jahresberichten an, 
andere präsentieren Daten interaktiv in Form von Zahlen 
und Diagrammen. Fortgeschrittene Systeme nutzen auch 
Karten zur Präsentation der geografischen Verteilung 
von Erregern. Drei dieser Systeme werden im Folgenden 
vorgestellt.

  SurvStat vom Robert Koch-Institut [survstat:05]

Dieses System erlaubt den Zugriff auf die vom RKI 
erfassten Krankheitsfälle und Erregernachweise. Es 
ergänzt die bisher in Form des "Epidemiologischen Bulletins"
 und des "Infektionsepidemiologischen Jahrbuchs" vom 
Institut angebotenen Informationen. Der Anwender des 
Systems kann über die Benutzeroberfläche verschiedene 
Parameter einstellen (siehe Abbildung [fig:Benutzeroberfläche-von-SurvStat], linke Seite). 
SurvStat erlaubt das Filtern der Daten nach 
spezifischen Krankheiten bzw. Erregern, Zeiträumen, 
Orten, Personendaten und Falldefinitionen. Die 
Abfrageergebnisse lassen sich anhand eines unter diesen 
Kategorien verfügbaren Merkmals (Geschlecht, 
Altersgruppe, Quartal, Landkreis, etc.) gruppieren. 
Weiterhin kann der Anwender ein zusätzliches zweites 
Merkmal für eine kreuztabellarische Abfrage angeben. 

In dem Kreisdiagramm auf der rechten Seite von 
Abbildung [fig:Benutzeroberfläche-von-SurvStat] sind die Meningokokkenfälle 2005 nach den 
Serogruppen eingegrenzt B, C und Y gruppiert. 

<Grafikdatei: figures/survstat.eps>


<fig:Benutzeroberfläche-von-SurvStat>Benutzeroberfläche von SurvStat. Das System erzeugt 
anhand der in der Maske eingestellten Parameter unter 
anderem Kreisdiagramme. (Bildschirmfoto, Stand: 05.12.2005)

SurvStat ist ein sehr umfangreiches System. Es kann auf 
den vereinfachten Datenbestand des RKI zugreifen. Die 
Daten sind sehr aktuell (wöchentliche Aktualisierung). 
Ein Nachteil ist die clientseitige Umsetzung mittels 
JavaScript und HTML. Nahezu jeder Mausklick führt zu 
einer kompletten Aktualisierung der Website. Zudem 
zeigt eine durchgeführte Anfrage das Ergebnis in einem 
separaten Browser-Fenster an. Diese beiden Faktoren 
hemmen den Arbeitsfluss.

  Arbeitsgemeinschaft Influenza [agi:05]

Die Arbeitsgemeinschaft Influenza (AGI) informiert die 
Bevölkerung während der Wintersaison über die Aktivität 
der auch unter dem Namen "Grippe" bekannten Influenza. 
Dieses Projekt ermöglicht es dem Anwender nicht, Filter 
einzustellen, um ausführliche Tabellen und Diagramme zu 
erzeugen. Zudem beschränkt es sich im Vergleich zu 
SurvStat auf lediglich einen Erreger. Der Grund dafür, 
dass es trotzdem hier als Beispiel angebracht wird, ist 
die gute Präsentation der aktuellen 
Erkrankungssituation. 

Die AGI verwendet in ihrem Internetangebot 
übersichtliche Karten (Abbildung [fig:Aktivität-der-Influenza]), um die Verteilung 
von Erkrankungsfällen in Deutschland intuitiv zu 
vermitteln. Sie veranschaulicht zudem die Dynamik der 
Erregeraktivität durch Animationen mit einem Bild pro 
Kalenderwoche. Der Benutzer kann neben dieser 
Darstellung noch eine vorgegebene Menge von Diagrammen 
anfordern. Diese zeigen die zeitliche Verteilung 
verschiedener Messwerte für das Bundesgebiet und die 
Länder. Das Angebot der AGI bietet keine interaktiv 
änderbaren Karten oder Diagramme.

<Grafikdatei: figures/agi1.png>


<fig:Aktivität-der-Influenza>Aktivität der Influenza in der 6. Kalenderwoche 2005 
(AGI-Website, Stand: 05.12.2005)

  Swedish Institute for Infectious Disease Control 
  (SMI) [smi:05]

Das SMI ist eine schwedische Behörde, die mit der 
Epidemiologie von Infektionskrankheiten betraut ist. 
Das Institut bietet auf seiner Website ausführliche 
Statistiken zu meldepflichtigen Erkrankungsfällen in 
Schweden. Die Menge der unterschiedenen 
Krankheitserreger ist mit der von SurvStat 
vergleichbar. Rolfhamre et al. [rolfhamre:04] beschreiben den 
web-basierten Dienst, welcher der Öffentlichkeit seit 
Mai 2003 Zugriff auf die Daten des SMI ermöglicht. Das 
System präsentiert die Statistik zu den erfassten 
meldepflichtigen Krankheiten in verschiedener Weise:

* Tabellen zeigen die Anzahl der Fälle und Inzidenz 
  nach Kreisen als Monats- und Jahresstatistik und die 
  Altersverteilung nach Gruppen oder die 
  Geschlechterverteilung als Jahresstatistik an.

* Graphen informieren über die gesamte Anzahl der Fälle 
  pro Woche und deren Trend.

* Karten veranschaulichen die geografische Verteilung 
  der Erkrankungszahlen und die Inzidenz anhand der 
  Einfärbung von Kreisen (Abbildung [fig:SMI-Inzidenz-Meningokokkenerkrankungsfälle]).

<Grafikdatei: figures/smi1.png>


<fig:SMI-Inzidenz-Meningokokkenerkrankungsfälle>Inzidenz der Meningokokken-Erkrankungsfälle in Schweden 
von Januar bis Oktober 2005 (Bildschirmfoto, Stand: 06.12.2005)

Die schwedischen Wissenschaftler haben mit diesem 
Onlineangebot eine Möglichkeit geschaffen, 
Interessenten mit Hilfe von GIS online über die 
epidemiologische Situation in ihrem Land zu 
informieren. Das Angebot an Statistiken ist, die Anzahl 
der erfassten Erkrankungen betreffend, sehr 
umfangreich. Im Vergleich zu SurvStat behandelt es 
allerdings alle verschiedenen Krankheitserreger gleich. 
Unter den Meningokokkenerkrankungen tauchen zum 
Beispiel keine Serogruppen auf. Die 
Interaktionsmöglichkeiten des Benutzers beschränken 
sich auf die Auswahlmöglichkeit bestimmter Jahre bei 
den angezeigten Karten. Alle anderen Inhalte sind 
statisch. Die Daten im System werden lediglich einmal 
im Monat aktualisiert.

4.2 Anforderungen an ein web-basiertes 
  epidemiologisches GIS

Die im vorigen Abschnitt genannten Beispiele für 
epidemiologische Informationsplattformen vermitteln 
bereist einige Anforderungen an das zu entwickelnde 
System. Gleichzeitig zeigen sie auch, dass öffentlich 
zugängliche geografische Informationssysteme in diesem 
Bereich noch am Anfang stehen. Dies erstaunt umso mehr, 
als Karten bereits für die ersten Menschen ein Mittel 
waren, Informationen auszutauschen (z.B. Strategien für 
eine Jagd) [barnes:2005]. 

Das öffentlich zugängliches Informationssystem muss dem 
Anwender intuitiv Daten und Zusammenhänge vermitteln. 
Die folgend aufgeführten Einzelkomponenten tragen 
jeweils zur Erfüllung dieser Aufgabe bei.

4.2.1 <sub:Reichhaltige-Internetanwendung>Reichhaltige Internetanwendung als Benutzerschnittstelle

Die Beispielsysteme aus Abschnitt [sec:Web-basierte-Systeme] haben alle den 
Nachteil, dass sie HTML-Dokumente verwenden, um dem 
Benutzer Informationen zu präsentieren. Jede 
Interaktion erfordert eine Anfrage des Browsers an den 
Server. Es kommt kein richtiger Arbeits- und 
Informationsfluss zu Stande.

Die Lösung dieses Problems heißt "Rich Internet Applications"
 (RIAs), wobei "Rich" reichhaltig bedeutet. Der Benutzer 
lädt RIAs über eine Website direkt aus dem Internet. Im 
Vergleich zu HTML-Seiten sind sie um Funktionen 
angereichert, die sonst nur von Desktop-Applikationen 
bekannt sind. IDCInternational Data Corporation [idc:05] hat in einem White Paper [duhl:2003] die 
Verwendbarkeit von RIAs für Firmen bewertet. Für den 
Einsatz als clientseitige Schnittstelle eines 
epidemiologischen Geoinformationssystems sprechen mehr 
Vor- als Nachteile:

  Vorteile

* Der Benutzer kann die Client-Anwendung "überall" verwenden.

* RIAs bieten auf verschiedenen Hard- und 
  Softwaresystemen immer die gleiche Funktionalität.

* Die Anwendung wird clientseitig ausgeführt. Einmal 
  geladen, muss sie nur noch wenige Daten mit dem 
  Server austauschen.

* Die Benutzeroberfläche ist eingängig und erlaubt ein 
  hohes Maß an Interaktivität. Sie "fühlt" sich wie eine 
  Desktop-Anwendung an.

* Die Medien Text, Bild, Audio und Video lassen sich in 
  der Präsentation nahtlos verbinden.

* Im Gegensatz zu Desktop-Anwendungen sind Updates für 
  den Benutzer sofort verfügbar.

* Der Anwender setzt seinen Rechner durch die 
  Ausführung von RIAs keinem Sicherheitsrisiko aus ("Sandbox"
  -Prinzip [ludwig:2005]). 

 Nachteile

* RIAs benötigen für die Ausführung ein im Browser 
  installiertes Plugin. Benutzer von Systemen, auf 
  denen diese Software-Komponente nicht installiert 
  werden kann, haben keine Möglichkeit, die 
  Internetanwendung auszuführen.

* Der initiale Ladevorgang dauert länger als bei einer 
  HTML-Seite.

Die RIA für  ist mittels Flash umgesetzt. Viele 
Benutzer haben das Flash-Plugin der Firma AdobeDie Firma Macromedia, die Flash vormals entwickelt hat, 
ist am 5. Dezember 2005 von Adobe übernommen worden.
 [adobe:05] auf ihrem Rechnern installiert (siehe Tabelle [tab:Weltweite-Verbreitung-Flash]). 
Diese Daten sprechen für die Verwendung von Flash zur 
Entwicklung eines erreichbaren Informationssystems.

         || Version 5  | Version 6  | Version 7 |
---------++------------+------------+-----------+
---------++------------+------------+-----------+
   USA   ||   97,3%    |   96,4%    |   91,9%   |
---------++------------+------------+-----------+
  Kanada ||   98,7%    |   97,5%    |   93,8%   |
---------++------------+------------+-----------+
  Europa ||   98,7%    |   97,4%    |   93,3%   |
---------++------------+------------+-----------+
  Asien  ||   96,6%    |   94,0%    |   87,7%   |
---------++------------+------------+-----------+


<tab:Weltweite-Verbreitung-Flash>Ergebnisse einer weltweiten Umfrage über die 
Verbreitung des Flash-Plugins [npdgroup:05] (Stand: September 2005)

Als epidemiologisches GIS muss die Rich Internet 
Application dem Benutzer folgende Funktionen bieten:

* Anzeigen von verschiedenen Karten mit der 
  Möglichkeit, zwischen diesen direkt umzuschalten

* Verschieben und Vergrößern des gezeigten Kartenausschnitts

* Abfragen von Detailinformationen zu einzelnen Punkten 
  auf der Karte

* Filtern der epidemiologischen Daten nach 
  Altersgruppen, Zeitraum und spezifischen 
  Erreger-Merkmalen (z.B. Serogruppe)

* Ausgeben einer druckfähigen Version der Karte

Weitere Anforderungen an die Benutzeroberfläche sind 
Geschwindigkeit und intuitive Bedienbarkeit.

4.2.2 <sub:Anf-Geografisches-Informationssystem>Geografisches Informationssystem

Das geografische Informationssystem in diesem Projekt 
erzeugt verschiedene epidemiologische Übersichtskarten. 
Das GIS muss dabei mehrere Anforderungen erfüllen.

  Karten setzen sich aus Ebenen zusammen

Digitale Karten sind in Geoinformationssystemen 
meistens mittels Ebenen organisiert. Zusammengehörige 
Daten liegen in einer Ebene. Die Karte in Abbildung [fig:Karte-aus-Ebenen] 
enthält zum Beispiel die Ebenen Inzidenz, Grenzen, 
Städte und Erkrankungsfälle. In einer Ebene 
zusammengefasste Elemente sind immer vom gleichen 
geometrischen Typ. Bei Grenzen und Inzidenz handelt es 
sich um Flächen-, bei Städten und Erkrankungsfällen um 
Punktinformationen. Die einzelnen Schichten erzeugen 
zusammen das Gesamtbild der Karte. Der Benutzer kann 
die Darstellung durch Ein- und Ausblenden einzelner 
Ebenen verändern.

<Grafikdatei: figures/ebenen.eps>


<fig:Karte-aus-Ebenen>Eine Karte wird im GIS aus einzelnen Ebenen aufgebaut

  Dynamische Karten

Durch die Ebenen hat der Anwender Einfluss auf die 
angezeigten Informationen. Das GI-System muss zudem 
auch auf die unter [sub:Reichhaltige-Internetanwendung] beschriebenen Filter reagieren. 
Einzelne Ebenen besitzen dazu Parameter, anhand derer 
die Darstellung erzeugt wird. Die Inzidenz-Ebene stellt 
zum Beispiel die Inzidenz aller im gewählten Zeitraum 
aufgetretenen Fälle dar. Zusätzlich lässt sich die 
geografische Auflösung dieser Berechnungen (z.B. 
Bundesländer oder Kreise) einstellen.

  Zugriff auf Attributinformationen

Attributinformationen sind alle verfügbaren Daten außer 
den Koordinaten. Geoinformationssysteme speichern oft 
viele Zusatzdaten zu einem geografischen Eintrag. Die 
Einwohnerzahl einer Stadt ist beispielsweise ein 
Attribut. Verschiedene Farben und Symbole können 
mögliche Attributwerte repräsentieren. Ergänzend zu 
dieser Informationsdarstellung muss das GI-System 
allerdings auch Detailinformationen zu einer bestimmten 
Position oder Region auf der Karte liefern können. Die 
Inzidenz lässt sich wie beim schwedischen System in 
Abschnitt [sec:Web-basierte-Systeme] mit vier Farben darstellen. Der Benutzer 
dieses Systems kann aber nur mit den exakten 
Attributinformationen feststellen, ob die Inzidenz in 
einem Landkreis 0,71 oder 1,49 beträgt. Der 
Wertebereich von 0,7 bis 1,5 entspricht einer Farbe und 
erlaubt daher keine Differenzierung.

4.2.3 Aktualisierung der Daten

Die Aktualität der von einem Informationssystem 
bereitgestellten Daten ist insbesondere bei der 
Überwachung von Erkrankungsfällen von großer Bedeutung. 
Die Epidemiologen müssen in der Lage sein, die im 
System gespeicherten Falldaten regelmäßig und 
automatisiert zu aktualisieren, um auf Veränderungen 
reagieren zu können.

Das Referenzzentrum/Labor überträgt die Daten in einem 
vereinbartem Transferformat an den Server. Eine sichere 
Übertragungsleitung gewährleistet den Schutz der 
sensiblen Informationen. Der Server führt eine 
Aktualisierung der Datenbank durch. 

4.2.4 <sub:Automatische-Identifizierung-Cluster>Automatische Identifizierung von Clustern

Für Epidemiologen ist die Identifizierung von Clustern 
(siehe auch Abschnitt [sec:Identifizierung-von-Clustern]) ein wichtiges Hilfsmittel. Es 
lenkt ihre Aufmerksamkeit auf Einzelfälle, die sie 
genauer untersuchen müssen.  ist das erste web-basierte 
epidemiologische GIS, das diese Analysen automatisiert 
durchführen kann. Es übernimmt damit die Aufgabe eines 
Frühwarnsystems. 

Das NRZM wendet bei der Clusteridentifizierung zwei 
verschiedenen Verfahren an. Der Server muss diese 
mittels SaTScan automatisch, basierend auf den 
aktuellen Falldaten, ausführen.

  Prospektive Analyse

Die prospektive Analyse ist ein Frühwarnsystem. Sie 
kann Ausbrüche von Erkrankungsfällen, die gerade im 
Entstehen sind, frühzeitig erkennen [kulldorff:2001]. Sie reagiert sehr 
schnell auf Veränderungen. Die Suche nach aktuell 
vorhandenen ("lebenden") Clustern soll wöchentlich 
durchgeführt werden. Das NRZM setzt eine maximale 
Clusterdauer von 60 Tagen fest. Das System soll immer 
nur das Ergebnis der aktuellsten prospektiven Analyse anzeigen.

  Retrospektive Analyse

Die Retrospektive Analyse liefert alle in der 
Vergangenheit aktiven Cluster. Diese historischen 
Erkrankungshäufungen sind keine akute Bedrohung der 
öffentlichen Gesundheit. Kulldorff et al. haben mit 
dieser Analyse z.B. nachgewiesen, dass ein scheinbar 
verstärktes Auftreten von Erkrankungen an Gehirntumoren 
in Los Alamos, New Mexico, reiner Zufall war. Sie 
konnten keinen Zusammenhang mit dem dort 1943 von der 
US-Regierung aufgebauten Kernforschungszentrum 
feststellen [kulldorff:1998]. 

Die Retrospektive Analyse soll in diesem System die 
historische Clusterlandschaft darstellen. Hierzu sollen 
die Berechnungen monatlich mit allen bisher erfassten 
Daten durchgeführt werden.

4.3 <sec:Open-Source-Software>Anwendungsrelevante freie Softwarepakete

  Definition 

Freie Software bedeutet die Freiheit des Benutzers, die 
Software zu benutzen, zu kopieren, sie zu vertreiben, 
zu studieren, zu verändern und zu verbessern. Genauer 
gesagt, bezieht sich der Begriff "Freie Software" auf 
vier Arten von Freiheit, die der Benutzer der Software hat:

  Die Freiheit, das Programm für jeden Zweck zu 
  benutzen (Freiheit 0).

  Die Freiheit, zu verstehen, wie das Programm 
  funktioniert und wie man es für seine Ansprüche 
  anpassen kann (Freiheit 1). Der Zugang zum Quellcode 
  ist dafür Voraussetzung.

  Die Freiheit, Kopien weiterzuverbreiten, so dass man 
  seinem Nächsten weiterhelfen kann (Freiheit 2).

  Die Freiheit, das Programm zu verbessern und die 
  Verbesserungen der Öffentlichkeit zur Verfügung zu 
  stellen, damit die ganze Gemeinschaft davon 
  profitieren kann (Freiheit 3). Der Zugang zum 
  Quellcode ist dafür Voraussetzung."

Free Software Foundation - Die Definition freier 
Software [fsf_def:05] 

Open-Source-Software [oss:05, OSS] und freie Software [fsf:05] sind 
bedeutungsgleich. Die Verfechter der jeweiligen 
Bewegung setzen allerdings unterschiedliche 
Schwerpunkte. Diese Arbeit verwendet die beiden 
Begriffe synonym. 

Bei der Entwicklung dieses Projektes war es wichtig, 
nicht-proprietäre Software-Produkte zu finden, welche 
die in diesem Kapitel definierten Anforderungen 
erfüllen. Nicht alle im Folgenden genannten Produkte 
sind verwendet worden.

4.3.1 <sub:Web-basierte-Anwendungen>Web-basierte Anwendungen

 Struts als serverseitiges Framework

Jakarta Struts [struts:05] ist ein Framework zur Entwicklung von 
auf JavaServer Pages [jsp:05, JSP] basierenden dynamischen 
Internetseiten. Struts implementiert in Teilen Suns "Model-2"
-Architektur [seshadri:1999]. Hierbei handelt es sich um eine für 
Webanwendungen angepasste Version des 
Model-View-Controller Architekturmusters [reenskaug:1979]. Abbildung [fig:Model-2-Architektur] 
zeigt das Zusammenspiel der MVC-Komponenten im "Model-2".

<Grafikdatei: figures/model2.eps>


<fig:Model-2-Architektur>"Model-2"-Architektur: Modell-View-Controller für Webanwendungen

Struts bringt bei der Entwicklung von Webanwendungen 
verschiedene Vorteile [kuhn:2003]: 

* Durch eine Implementierung mit wenigen überschaubaren 
  Komponenten ist das Framework leicht zu erlernen. 
  Gleichzeitig bietet es genug Freiraum für 
  experimentierfreudige Entwickler.

* Alle Funktionen von Java Servlets bleiben erhalten. 
  Struts lässt sich mit Bibliotheken kombinieren.

* Informationen lassen sich einfach zwischen Objekten 
  und HTML-Formularen verschieben.

* Struts verwaltet alle Einstellungen in einer 
  zentralen XML-Datei. Sie ist trotz umfangreicher 
  Konfigurationsmöglichkeiten gut verständlich.

* Struts arbeitet gut mit anderen auf Java Servlets 
  beruhenden Frameworks zusammen.

Die zentrale Komponente von Stuts ist ein 
Front-Controller. Dieser ist der zentrale Zugangspunkt 
für die Webanwendung. Er nimmt alle Anfragen entgegen 
und erledigt sie selbst oder leitet sie an andere 
Klassen weiter. 

Dieses Projekt verwendet Struts als serverseitiges Framework.

 OpenLaszlo für Rich Internet Applications

OpenLaszlo [openlaszlo:2005] ist eine von Laszlo Systems, Inc. 
enwickelte Software-Platform zur Entwicklung und 
Verbreitung von Rich Internet Applications (siehe 
Abschnitt [sub:Reichhaltige-Internetanwendung]). Laszlo Systems stellt der Öffentlichkeit 
die Software seit Oktober 2004 unter einer Open-Source-LizenzCommon Public License (CPL 1.0)
 zur Verfügung. Die Firma will damit die Verbreitung 
von RIAs und somit auch ihre anderen kommerziellen 
Produkte und Dienstleistungen fördern.

OpenLaszlo erweitert die Vorteile, die für den Einsatz 
RIAs sprechen:

* Die Open-Source Lösung ist dank langer Entwicklung 
  stabil und gut dokumentiert.

* Die Programmiersprache ist objektorientiert und 
  komponenten-basiert.

OpenLaszlo verwendet Flash als Zielplattform für 
Internet-Anwendungen. Der Quellcode basiert auf XML und 
JavaScript. Die Programmiersprache mit dem Namen LZX 
ist eine objektorientierte, ereignisgesteuerte 
Auszeichnungssprache. Der Entwickler kann darin 
programmierte Anwendungen auf zwei verschiedene Arten 
verteilen (siehe Abbildung [fig:Laszlo-Architektur]). 

<Grafikdatei: figures/laszlo_arch.eps>


<fig:Laszlo-Architektur>Übersicht der Architektur von OpenLaszlo. 
Laszlo-Anwendungen lassen sich eigenständig ("Solo Deployment"
) oder in Verbindung mit einem Java Servlet Container 
einsetzen. (Quelle: Laszlo Systems [laszlo_press:2005])

Bei dem "Solo Deployment" stellt ein Webserver (z.B. 
Apache) die bereits in das Flash-Format kompilierte 
Applikation bereit. Die im Browser des Benutzers 
laufende Flash-Anwendung kann hierbei dynamisch Daten 
aus XML-Dateien oder XML-generierenden serverseitigen 
Skripten laden. 

Die zweite Verteilungsmöglichkeit benötigt einen Java 
Servlet Container (z.B. Apache Tomcat). Das auf diesem 
laufende OpenLaszlo Servlet übersetzt die Quellen der 
Anwendung zur Laufzeit und liefert Flash-Bytecode an 
den Browser aus. Diese Anwendung erlaubt im Vergleich 
zum "Solo Deployment" auch den Zugriff auf 
java-spezifische Ressourcen.

  Beispiele für OpenLaszlo-Anwendungen

Die folgenden kurzen Laszlo-Programme veranschaulichen, 
wie die in XML programmierten Anwendungen aufgebaut 
sind. 

Listing [lst:laszlo_hello] zeigt das beispielhaft oft eingesetzte 
Hallo-Welt-Programm. Das Wurzel-Element von LZX ist . 
Dieses Container-Element enthält alle weiteren Teile 
einer Anwendung, wie in diesem Fall den Text "Hallo Welt!".



Das Programm in Listing [lst:laszlo_clickhello] demonstriert den Einsatz einer 
Ereignisbehandlungsroutine. Das -Element sorgt für eine 
zeilenweise Anordnung der im Container enthaltenen 
Objekte. Der  reagiert auf sein -Ereignis damit, dass 
er das seinem Elternobjekt untergeordnete Element mit 
dem Namen  anzeigt.



Die beiden Beispiele zeigen nur die grundlegendsten 
Möglichkeiten von Laszlo-Anwendungen. Für 
weiterführende Informationen sei an dieser Stelle auf 
die Online-Dokumentation von OpenLaszlo verwiesen [openlaszlo_doc:2005]. 
Eine kurzweilige 10-Minuten-Einführung in die 
Laszlo-Programmierung findet sich unter der 
Internetadresse [http://www.laszlosystems.com/lps/laszlo-in-ten-minutes/]. Diese Website zeigt einfache 
Beispielanwendungen und erlaubt es diese Online zu 
bearbeiten und zu kompilieren.

 Bewertung

Mit OpenLaszlo existiert ein leistungsfähiges und gut 
dokumentiertes Open-Source-Projekt für die Entwicklung 
von RIAs. Es lässt sich ideal auf einem Java Servlet 
Container einsetzen. Laszlo bietet viele Komponenten 
zum Aufbau von web-basierten Benutzerschnittstellen. 
Die Leistungsanforderungen der produzierten 
Flash-Anwendungen in Bezug auf CPU und Bandbreite sind 
vertretbar. Diese Aussage basiert auf einem Test in dem 
die in diesem Projekt entwickelte Anwendung an einem 
Rechner mit 300 MHz und eine Modemanbindung mit 56 
kBit/s ausgeführt wurde. Die Programmierung von 
Anwendungen mit einer Auszeichnungssprache ist 
ungewöhnlich. Positiv ist die daraus resultierende 
Möglichkeit, Anwendungen sofort "live" online kompilieren 
und testen zu können.

4.3.2 Datenbanksysteme

 <sub:PostgreSQL>PostgreSQL

PostgreSQL ist ein objektrelationales 
Datenbankmanagementsystem (ORDBMS). Die University of 
California at Berkeley Computer Science Department 
entwickelte diese Software ursprünglich in einem 
universitärem Projekt. Der Name dieser 
Datenbanksoftware spricht sich "post-gress-Q-L" aus. Die 
Namensgebung und Betonung soll auf die Fortführung des 
Ingres-Projektes an der selben Universität hinweisen.

PostgreSQL unterstützt die ISO/ANSI SQL92 und SQL99 
Standards. Es ist das fortschrittlichste 
Open-Source-Datenbanksystem. Auch aus diesem Grund 
haben viele Entwickler Erweiterungen für PostgreSQL 
hervorgebracht, die dieses Datenbanksystem um 
Spezialfunktionen (z.B. GIS oder Statistik) ergänzen.

Eine der Erweiterungen ist PostGIS mit GEOS (siehe 
Abschnitt [sub:Geografische-Informationssysteme]). Sie eröffnet in PostgreSQL die 
Möglichkeit, geografische Objekte zu speichern und mit 
diesen zu arbeiten. Diese Fähigkeit, die offene 
Software-Lizenz [postgresql:05] und ein guter Support durch eine große 
Nutzergemeinschaft sind nur einige der Vorteile, 
aufgrund derer sich PostgreSQL als Datenbank in einem 
epidemiologisches GIS besonders gut eignet.

 MySQL

MySQL ist eines der am weitest verbreiteten 
Open-Source-Projekte. Der Finne Michael Widenius hat 
diese relationale DBMS 1994 entwickelt. Es hat sich 
besonders im Bereich der Webdienste in Verbindung mit 
Apache etabliert und erfreut sich einer bis heute 
ungebremsten Beliebtheit.

Geoinformationssysteme setzten diese DBMS seltener ein 
als die Kombination PostgreSQL/PostGIS. MySQL erlaubt 
seit der Version 4.1 ebenfalls das Speichern von 
geometrischen Objekten. Diese Implementierung ist 
allerdings keine eigenständige Erweiterung wie bei 
PostgreSQL, sondern ein Teil des Gesamtsystems. Im 
Vergleich zu PostgreSQL bietet MySQL auch in anderen 
wissenschaftlichen Bereichen (wie z.B. Statistik) 
weniger Erweiterungsmöglichkeiten.

4.3.3 <sub:Geografische-Informationssysteme>Geografische Informationssysteme

 Offene Standards für GIS

Das Open Geospatial Consortium [ogc:2005, OGC] ist ein gemeinnützig 
arbeitendes Gremium, das Standards im Bereich von GIS 
entwickelt. Offene Standards eröffnen viele Vorteile, 
wenn es um den Austausch von Daten zwischen 
Organisationen geht. Die USGSUnited States Geological Survey integriert z.B. in ihrem "
The National Map"-Projekt mit Hilfe von OGC-Standards 
geografische Daten aus den unterschiedlichsten Quellen 
in einer GIS-Anwendung [reed:2005].

Zwei vom OGC entwickelte Standards werden von in diesem 
Projekt eingesetzten Softwarekomponenten implementiert:

* OGC Simple Features Specification For SQL [ogc:1999, SFS]
  Diese Spezifikation definiert, wie ein SQL-DBMS um 
  eine geometrische Komponente erweitert werden kann. 
  Die Datenbank muss dazu geometrische Daten speichern, 
  aktualisieren und Abfragen in Bezug auf deren 
  Topologie durchführen können. Der Standard 
  spezifiziert auch Koordinatenprojektionen auf 
  geografischen Daten. 

* Web Map Service [ogc:2004, WMS]
  WMS bezeichnet einen Dienst, der in der Lage ist, 
  geografische Informationen in eine digitale Karte 
  umzuwandeln. Laut Definition handelt es sich hierbei 
  nicht mehr um reine Geodaten. Karten sind immer 
  grafische Darstellungen, die entweder mit Bitmaps 
  oder Vektorgrafiken realisiert sind. Ein WMS muss 
  nach diesem Standard folgende Operationen bereitstellen:

  * GetCapabilities
    Auf diese Anfrage hin gibt der WMS ein XML-Dokument 
    mit den angebotenen Informationen zurück. Es 
    beinhaltet unter anderem Metadaten des Dienstes, 
    Auskunft über unterstützte Kartenprojektionen und 
    angebotene Kartenebenen. 

  * GetMap
    Dieser Request liefert eine digitale Karte zurück. 
    Diese kann beispielsweise nur einen Ausschnitt der 
    angebotenen Region mit einer Teilmenge der 
    möglichen Ebenen darstellen.

  * GetFeatureInfo (optional)
    Ein WMS, der diese Operation unterstützt, erlaubt 
    es, Attributinformationen (siehe Abschnitt [sub:Anf-Geografisches-Informationssystem]) an 
    beliebigen Positionen der mit GetMap erzeugten 
    Karte abzufragen. 

Ramsey [ramsey:2005] gibt in "The State of Open Source GIS" einen 
umfassenden Überblick der zur Zeit verfügbaren 
Softwarelösungen für freie Geoinformationssysteme. Das 
System  nutzt folgende Werkzeuge aus diesem Bereich:

 UMN MapServer

Der UMN MapServer ist eine Entwicklung der University 
of Minnesota, Minneapolis. Er ist kein vollständiges 
GI-System. Schon der Name hebt hervor, dass dieser 
Server "nur" Karten ausgibt. In dieser Disziplin 
überzeugt das Projekt in Bezug auf Geschwindigkeit 
sowie die Vielzahl an implementierten Standards und 
unterstützten Datenformaten. 

Der Mapserver implementiert den WMS-Standard 
einschließlich der Version 1.1.1. Mit den im vorigen 
Abschnitt beschriebenen Operationen erfüllt er bereits 
einen Teil der auf Seite [sub:Anf-Geografisches-Informationssystem] festgelegten Anforderungen an 
die GIS-Komponente. Abbildung [fig:Mapserver-WMS] zeigt die Kommunikation 
einer WMS-Client-Anwendung mit dem MapServer. Der 
Server beantwortet die GetCapabilities-Anfrage indem er 
die in einer Konfigurationsdatei (siehe auch Listing [lst:mapserver_simple]) 
festgelegte Kartendefinition als XML-Dokument 
ausliefert. Der Client fordert mittels GetMap bestimmte 
Ebenen als GIF-Grafik an. Der MapServer erzeugt anhand 
der Geo- und Attributinformationen aus der Datenbank 
ein Bild und liefert es zurück.

<Grafikdatei: figures/mapserver.eps>


<fig:Mapserver-WMS>Mapserver in seiner Funktion als WMS

 PostGIS

PostGIS erweitert PostgreSQL mit geografischen Fähigkeiten:

* Speichern von geometrischen Objekten (point, line, 
  polygon, multipoint, multiline, multipolygon, 
  geometrycollections)

* Erzeugen von räumlichen Indizes

* Projizieren zwischen verschiedenen 
  Koordinatensystemen mittels der Bibliothek PROJ.4 [proj4:05]

* Abfragen von topologischen Relationen mittels der 
  GEOS-Bibliothek [geos:05]

* Im- und Exportieren von geografischen Daten

PostGIS implementiert die SFS des OGC in großen Teilen. 
Viele andere Open-Source-Projekte nutzen 
PostgreSQL/PostGIS als geometrische Datenbank.

 GeoTools

GeoTools [geotools:2005] ist eine java-basierte Open Source 
GIS-Bibliothek. Das Projekt implementiert die vom OGC 
verabschiedeten Standards. Es vereinfacht damit die 
Entwicklung von standardisierter GIS-Software in Java. 

GeoTools stellt in diesem Projekt nur die initiale 
Verbindung zu dem WMS des MapServers her um die 
Informationen über die verfügbaren Kartenebene zu erlangen.

4.3.4 Statistiksoftware

 <sub:SaTScan>SaTScan

Die Software SaTScan analysiert räumliche, zeitliche 
und raum-zeitliche Daten mit Hilfe der entsprechenden 
statistischen Analysemethode. Martin Kulldorff hat das 
Werkzeug für die folgenden in gegenseitiger Beziehung 
stehenden Aufgaben entwickelt [kulldorff:2005]:

* Überwachung von Erkrankungen durch die 
  Identifizierung von räumlichen oder raum-zeitlichen 
  Clustern und die Auswertung deren statistischer Signifikanz.

* Überprüfung, ob sich Erkrankungsfälle zufällig über 
  Raum, Zeit oder beide Dimensionen verteilen.

* Auswertung der statistischen Signifikanz alarmierend 
  erscheinender Erkrankungshäufungen.

* Identifizierung von Erkrankungsausbrüchen durch 
  regelmäßige Analyse der aktuellsten Falldaten.

SaTScan ist in der Epidemiologie der de facto Standard, 
wenn es um die Identifizierung von Erkrankungs-Clustern 
geht. 

 R

R [r:2005] ist eine Programmiersprache und Laufzeitumgebung für 
statistische Berechnungen und Visualisierungen. Seine 
leichte Erweiterbarkeit hat dazu geführt, dass es 
diverse statistischen Methoden zur Datenanalyse 
unterstützt. R kann unter anderem komplexe 
Zusammenhänge anhand verschiedenster Diagrammtypen 
veranschaulichen.

Im Zusammenhang mit einem web-basierten System lässt 
sich R leider nur bedingt einsetzen. Die eigentliche 
Softwareumgebung ist ein Kommandozeilenprogramm mit 
optionaler grafischer Ausgabe. 

Abhilfe schafft die von Joseph Conway entwickelte 
Software PL/R [conway:2005]. Hierbei handelt es sich um eine 
prozedurale Sprache, die PostgreSQL um die Funktionen 
von R erweitert. Die unterstützte Funktionalität reicht 
von der Berechnung des Medians einer Zahlenreihe bis zu 
der Erzeugung von komplexen Grafiken.



Konzepte

Das folgende Kapitel beschreibt alle wichtigen 
Konzepte, die beim Entwurf und der Entwicklung des 
Softwaresystems  verwendet wurden. Das Hauptaugenmerk 
ist dabei auf die client- und serverseitige Anwendung 
zur Erzeugung von epidemiologischen Karten gerichtet. 
Die Applikation soll Änderung der dargestellten Karten 
leicht ermöglichen. Zudem soll Sie sich mit möglichst 
wenig Aufwand auf andere Krankheitserreger und/oder 
ander Länder übertragen lassen können.

Der erste Abschnitt beschreibt den Zusammenhang und die 
Einzelheiten der client- und serverseitigen 
Komponenten. Abschnitt [sec:Leichte-Erweiterbarkeit] stellt die Bereiche vor, in 
denen die Architektur erweitert werden kann. Das 
letzten Unterkapitel behandelt Faktoren, die bei der 
Integration des MapServer als externes Werkzeug 
berücksichtigt werden müssen.

5.1 Datenmodell, Präsentation und Programmsteuerung

Die Überschrift dieses Abschnittes steht für die 
Übersetzung des Begriffs "Model-View-Controller" (MVC). 
Dieses Architekturmuster sieht folgende Komponenten 
vor: 

* Das Datenmodell (Model) bezeichnet alle 
  Informationen, die einer Anwendung zugänglich sind. 
  Es hat beispielsweise Zugriff auf eine Datenbank.

* Die Präsentation (View) ist die für den Benutzer 
  sichtbare Anwendung. Sie bildet das Datenmodell in 
  einer visuell erfassbaren Form ab.

* Die Programmsteuerung (Controller) steht zentral. Sie 
  hat Zugriff auf das Datenmodell und steuert alle Prozesse.

Der MVC-Ansatz ermöglicht die Entwicklung von 
modularen, erweiterbaren Anwendungen. Jede 
Teilkomponente übernimmt dabei klar definierte 
Aufgaben. Für die Webanwendung dieses epidemiologischen 
GI-Systems sind die einzelnen Verantwortlichkeiten wie 
folgt verteilt:

* Der MapServer und JavaBeans [javabeans:2005] bilden mit der Datenbank 
  das Modell. 

* Die in OpenLaszlo implementierte RIA, über JSP 
  erzeugte HTML-Dokumente und digitale Grafiken 
  übernehmen die Präsentation. 

* Struts steuert die serverseitigen Abläufe.

Abbildung [fig:Verwendung-des-MVC-Architekturmusters] verdeutlicht das Zusammenspiel der Komponenten.

<Grafikdatei: figures/mvc.eps>


<fig:Verwendung-des-MVC-Architekturmusters>Verwendung des MVC-Architekturmusters in EpiDeGIS

5.1.1 <sub:Globale-und-benutzerspezifische>Globale und benutzerspezifische Daten

 Datenbankkonzepte

Das PostgreSQL Datenbanksystem speichert alle im 
gesamten System benötigten und entstehenden 
Informationen. Diese sind in mehreren Tabellen abgelegt 
(siehe [sub:Tabellen]).  setzt zwei Konzepte ein, um 
Änderungsmöglichkeiten des Systems auf Datenbankebene 
zu gewährleisten.

  Übertragbarkeit auf andere Länder und oder 
  geografische Hierarchien

Geografische Daten stehen zueinander immer in einer 
topologischen Beziehung. Bei Flächendaten spiegelt 
diese häufig die Hierarchie wider. 

Für Deutschland lautet sie z.B. Bundesgebiet \rightarrow  Länder \rightarrow  
Regierungsbezirke \rightarrow  Landkreise und auch andere Länder 
bzw. Strukturen sind räumlich und organisatorisch auf 
diese Weise geordnet (z.B. Universitätsklinikum 
Würzburg \rightarrow  Abteilungen/Kliniken \rightarrow  Gebäude \rightarrow  Stockwerke \rightarrow  
Zimmer). 

Die Datenbank bildet solche Strukturen mittels zwei 
Tabellen ab. Eine speichert die Hierarchie und die 
verschiedenen Arten von erfassten Strukturen. Die 
zweite Tabelle enthält die zu bestimmten Typen 
gehörenden polygonale Daten (siehe Abbildung [fig:Hierarchische-Speicherung-von-Gebieten]).

<Grafikdatei: figures/db_gebiete.eps>


<fig:Hierarchische-Speicherung-von-Gebieten>Hierarchische Speicherung von Gebietsinformationen

Die Daten lassen sich bei dieser Struktur leicht um ein 
anderes Land erweitern: Holländische Epidemiologen 
wenden für Meningokokken ebenfalls die PorA/FetA 
-Feintypisierungsmethode an. Integration der 
holländischen Daten erfordert eine Definition der 
Hierarchie mit den drei Einträgen Nederlandse \rightarrow  
Provincies, \rightarrow  Gemeentes in der Tabelle der Gebietstypen. 
Im zweiten Schritt müssen die Grenzdaten der jeweiligen 
Bereiche unter den Gebieten abgelegt werden.

  Erweiterbarkeit der epidemiologischen Datenstruktur 
  um beliebig viele Attribute

Das Datenbankkonzept erlaubt es, die gepeicherten 
Falldaten um beliebige Attribute zu erweitern. 

Es legt dabei in einer Tabelle zu jedem Fall nur solche 
Daten ab, die auf alle Proben von Krankheitserregern 
zutreffen: 

* eine eindeutige Nummer, die intern (z.B. im NRZM) 
  eine Zuordnung zu detaillierten Probedaten erlaubt

* das Alter

* das Geschlecht

* das Eingangsdatum der Probe im Labor

* das Entnahmedatum beim Arzt

* die Koordinaten (Länge und Breite) des Ortes, in dem 
  der Fall aufgetreten ist

* die eindeutige Kennzeichnung des Erregertyps (z.B. 
  der Feintyp bei Meningokokken)

 setzt Attribute ein, um spezifische Merkmale eines 
Erregertyps außerhalb der Grundstruktur abzulegen: 

Ein vom NRZM ermittelter Feintyp hat beispielsweise die 
Struktur {Serogruppe}:P1.{PorA}:F{FetA}. Die 
Kombination der einzelnen Attribute Serogruppe, PorA 
und FetA kennzeichnet einen Meningokokkenerreger 
eindeutig. Die Serogruppe für sich ist jedoch eine 
Gemeinsamkeit mehrerer Feintypen.

Die Datenbank soll diesen Zusammenhang speichern, ohne 
die obigen epidemiologischen Grunddaten um eine Spalte 
mit der Serogruppe ergänzen zu müssen. Das gelingt, 
indem sie für jeden Erregertyp beliebig viele Attribute 
zulässt. Der konkrete Feintyp B:P1.7-2,4:F1-5 besitzt 
dabei ein Attribut mit dem Namen "Serogruppe", das den 
Wert "B" trägt. Genauso wäre in diesem Fall ein Attribut "
Impfstoff für Deutschland vorhanden" mit dem Wert "Nein" 
denkbar (siehe Abbildung [fig:Definition-von-beliebig]).

<Grafikdatei: figures/db_attribute.eps>


<fig:Definition-von-beliebig>Definition von beliebig vielen Attributwerten für einen 
Erregertyp

Die Datenbank erweitert bisher nur den Erregertyp um 
Attribute. Für einzelne Erkrankungsfälle könnte das 
gleiche Konzept eingesetzt werden, um z.B. den Wert 
eines Attributes "Antibiotikaresistenz" festzuhalten.

 Daten im Servletcontainer

Eine Internet-Applikation muss Daten über den 
Anwendungszustand aus Sicht des Benutzers oder des 
Gesamtsystems serverseitig abspeichern. Der Java 
Servlet Container definiert für diese Informationen 
unterschiedliche Bereiche [struts_doc:2005]:

  Page Diese Daten sind nur während dem Verlauf einer 
  einzigen JSP gültig.

  Request Diese Informationen sind für die Dauer einer 
  Anfrage im System. Diese verläuft u.U. über mehrere 
  Seiten/Komponenten.
  Wenn der Benutzer z.B. den sichtbaren 
  Kartenausschnitt verschieben möchte, übermittelt die 
  RIA den Wunsch an den Server. Sobald dieser die 
  Aktion ausgeführt hat, löscht er die mit dem Request 
  verknüpften Informationen (hier \Delta x und \Delta y der 
  angeforderten Kartenverschiebung).

  Session Alle in diesem Bereich abgelegten Daten 
  bleiben so lange gültig, wie der Benutzer online mit 
  der Anwendung interagiert. Über die Konfiguration des 
  Tomcat Servers lässt sich festlegen, wie viele 
  Minuten die Session-Daten bei Inaktivität erhalten bleiben.

  Application Für die ganze Anwendung zugängliche Daten 
  werden hier gespeichert.

5.1.2 <sub:Präsentation-der-Informationen>Präsentation der Informationen

 Flashanwendung mit OpenLaszlo

Die Abbildung [fig:Verwendung-des-MVC-Architekturmusters] führt die Rich Internet Application als 
View auf. Der Anwender würde sie wahrscheinlich als 
View und Controller bezeichnen. So präsentiert sie ihm 
doch den Zustand des Systems bzw. seiner Session und 
erlaubt gleichzeitig Kontrolle durch Interaktion. Eine 
klarere Einordnung behandelt Client und Server getrennt.

Vom Server gesehen ist auch die RIA nichts anderes als 
eine View-Komponente. Im Moment einer Anfrage wird sie 
von dem Laszlo-Servlet kompiliert und an das 
Flash-Browser-Plugin auf dem Rechner des Benutzers 
ausgegeben. 

Sobald die Laszlo-Anwendung beim Benutzer geladen ist, 
bedient sie sich eines weiteren serverseitigen Views. 
Dieses stellt den für diesen Benutzer gültigen 
Systemzustand als XML dar. Die Technik von OpenLaszlo 
generiert die Benutzeroberfläche anhand dieser 
Information dynamisch (Abschnitt [sub:Dynamischer-Aufbau-der-GUI]). 

Der Server erzeugt auch die Darstellung der Karten, 
welche die RIA ihrerseits wieder anzeigt. Weiterhin 
überträgt sie jede Interaktion des Anwenders an den 
Server und kontrolliert damit auch den Programmfluss. 

Auf dem Client-Rechner bildet die Anwendung damit eine 
eigene MVC-Architektur. Ihr Controller gibt allerdings 
alle Eingaben des Benutzers an den Server weiter und 
reagiert auf dessen Antworten.

 HTML-Karte für den Druck

Flash-Anwendungen bieten dem Anwender zwar viele 
Möglichkeiten zur Interaktion, die Ausgabe der 
angezeigten Seite über einen Drucker ist allerdings nur 
im Rahmen der durch den Browser bereitgestellten 
Funktionen möglich. Zudem ist es bei einem 
epidemiologischen GI-System nicht im Interesse das 
Anwenders, das Abbild einer Benutzeroberfläche 
auszudrucken. Vielmehr sollte ein Bericht die aktuell 
sichtbare Karte, die Legende und Informationen zu den 
eingestellten Filtern ausgeben. 

Eine dynamisch über JavaServer Pages generierte 
HTML-Seite erfüllt diese Funktion. Sie lässt sich 
ausdrucken oder lokal speichern. Struts ist dafür 
verantwortlich die JSP mit Daten zu versorgen. Der 
Server muss dafür zu jeder Zeit in einem aus 
Anwendersicht gültigen Zustand sein. 

5.1.3 <sub:Wohldefinierte-Zustandsänderungen>Wohldefinierte Zustandsänderungen

OpenLaszlo motiviert den Entwickler dazu, die 
Programmlogik in der Clientanwendung zu implementieren. 
Dies entspricht dem Konzept von RIAs, indem es 
verzögerungsanfällige Kommunikation zwischen Client und 
Server minimiert. 

Diese Arbeit setzt, wie unter [sub:Präsentation-der-Informationen] erläutert, die 
clientseitige Anwendung nur als eine Form der 
Präsentation ein. Das schafft ein konsistentes 
Gesamtsystem, dessen Zustand nur der Server 
kontrolliert. Die Laszlo-Anwendung fungiert dabei als 
Schnittstelle, die alle Eingaben des Benutzers an den 
serverseitigen Controller (Struts) übermittelt. Die 
Kommunikation erfolgt über HTTP-Requests und 
zurückgegebene XML-Dokumente. 

Der Vorteil eines definierten serverseitigen Zustandes 
liegt darin, dass verschiedene Präsentationen ihn zu 
jeder Zeit gleich abbilden. Ein konkretes 
Beispielszenario ist folgendes:

Der Anwender startet die RIA und arbeitet damit. Er 
lässt sich beispielsweise auf einer Karte alle 
Erkrankungsfälle von 2-5 Jährigen im Jahr 2004 
anzeigen. Der Benutzer öffnet in seinem Browser 
versehentlich eine andere Website und schließt dabei 
die Flash-Anwendung. Sollte er sie noch einmal öffnen 
bevor sein Session-Timeout abgelaufen ist, so sind alle 
festgelegten Filter noch eingestellt, obwohl die 
clientseitige Anwendung bereits beendet war.

5.2 <sec:Leichte-Erweiterbarkeit>Leichte Erweiterbarkeit

Ein wichtiges Kriterium bei der Planung dieser Arbeit 
war es, ein epidemiologisches Geoinformationssystem zu 
schaffen, das erweiterbar ist. Abschnitt [sub:Globale-und-benutzerspezifische] hat 
Datenbankkonzepte vorgestellt, die einen Ausbau der 
abgelegten geografischen und epidemiologischen Daten zulassen.

In diesem Abschnitt soll es um Erweiterungen des 
Systems gehen, die im Java-Quellcode, beim MapServer 
oder an den Schnittstellen der Webanwendung ansetzen.

5.2.1 <sub:Dynamische-Karten>Dynamische Karten- und Ebenenparameter

Eine Reihe von Java-Klassen in diesem System modelliert 
den abstrakten Datentyp einer Karte. Sie enthält 
mindestens eine Ebene und hat beliebig viele "Kartenparameter"
. Eine Ebene kann "Ebenenparameter" besitzen (Abbildung [fig:Komposition-von-Karten]
). Die Parameter sind eine Ansammlung von möglichen 
Werten für ein Attribut, das entweder der ganzen Karte 
oder nur einzelnen Ebenen zugeordnet ist. 

<Grafikdatei: figures/uml_karte.png>


<fig:Komposition-von-Karten>Komposition von Karten, Ebenen und Parametern

Ein für die ganze Karte gültiger Auswahlparameter gibt 
beispielsweise an, welche geografischen Teilgebiete 
vergrößert betrachtet werden können. Er enthält z.B. 
für Deutschland die Werte Bundesgebiet, 
Baden-Württemberg, Bayern, ..., Thüringen. Wenn der 
Anwender ein anderes Gebiet auswählt, muss das System 
alle Kartenebenen aktualisieren. 

<Grafikdatei: figures/srceen_parameter.png>


<fig:Konkrete-Umsetzung-Parameter>Konkrete Umsetzung des Parameterkonzeptes in der Laszlo-Anwendung
Ebenenparameter arbeiten nach dem gleichen Prinzip. Von 
ihrem Attributwert ist allerdings nur eine Ebene 
abhängig. Ein Beispiel ist die Feintypen-Ebene der 
epidemiologischen Karte für das NRZM. Sie zeigt alle 
durch einen Feintyp verursachten Erkrankungsfälle im 
Gebiet an. Der zugehörige Parameter enthält damit alle 
möglichen Feintypen.

Das Parameterkonzept sichert Erweiterbarkeit in 
Hinblick auf Filter, anhand derer die Kartendarstellung 
beeinflusst werden kann. Die RIA bietet beispielsweise 
Parameter in Form von Dropdown-Listen an. Auf der 
Benutzeroberfläche sind Kartenparameter dabei immer 
sichtbar, während Ebenenparameter nur im Bereich einer 
Ebene erscheinen (siehe Abbildung [fig:Konkrete-Umsetzung-Parameter]).

Die Implementierung dieses Konzeptes hat zu 
Schwierigkeiten geführt, aufgrund derer sich die 
ursprüngliche Bedeutung von Karten- und 
Ebenenparametern verändert. Der Begriff des 
Kartenparameters ist in der grafischen 
Benutzeroberfläche ein vom Anwender einstellbarer Wert, 
dessen Steuerelement immer sichtbar ist. Für den 
Ebenenparameter ist dieses einer Ebene untergeordnet. 
Ein Kartenparameter ist dabei aber nicht zwangsläufig 
global für alle Ebenen verantwortlich und der Parameter 
einer Ebene kann seinerseits auch andere Ebenen beeinflussen.

Ein Beispiel veranschaulicht die Situation: Die Karte 
enthält zwei Ebenen. Eine zeigt Meningokokkenfälle 
gruppiert nach Serogruppen, die andere die zugehörige 
Inzidenz nach Landkreisen an. Ändert der Anwender die 
Serogruppe, so muss die Inzidenz-Ebene ebenfalls 
aktualisiert werden. In der Implementierung ist dieses 
Problem mit Platzhalter-Parametern gelöst, die einen 
existierenden Parameter referenzieren. Diese 
Implementierung bietet allerdings noch Raum für Verbesserungen.

5.2.2 <sub:Änderung-der-Kartendefinition>Änderbarkeit der Kartendefinition des MapServers

Abbildung [fig:Mapserver-WMS] zeigt, dass der MapServer die Konfiguration 
der von ihm angebotenen Karten über eine 
Definitionsdatei ("MapFile") einliest. Diese legt in 
einem definierten Format [doyon:2005] alle Eigenschaften der über 
den Server publizierten Karte fest. 

Dazu zählen unter anderem:

* Metadaten über den angebotenen Dienst (Name, Beschreibung)

* Globale Einstellungen der Karte (verwendetes 
  Koordinatensystem, die Grenzkoordinaten des 
  abgebildeten Gebietes, etc.)

* Definitionen der verschiedenen Kartenebenen

Ein Anbieter von epidemiologischen Informationen muss 
für Erweiterungen in der Karte hauptsächlich die 
Ebeneneinstellungen ändern. Diese definieren alle vom 
Anwender später sichtbaren Kartenelemente. Das sind 
beispielsweise die eingesetzten Farben und Symbole, die 
ein Merkmal auf der Karte auszeichnen, oder der Name 
einer Ebene. 

Der wichtigste Bestandteil jeder Ebene ist die 
Definition der Datenquelle. Beim MapServer können an 
dieser Stelle beliebige Abfragen an die Datenbank 
stehen, deren Änderung vielfältige Möglichkeiten zur 
Einflussnahme in die Kartenerzeugung bietet (siehe 
Abschnitt [sec:Definition-von-Karten]).

 integriert den MapServer auf die Art, dass Änderungen 
an der Kartendefinition grundsätzlich sofortsobald ein neuer Benutzer die Anwendung öffnet in der 
Benutzeroberfläche sichtbar sind. Eine statische Ebene "Flüsse"
, die in der "MapFile" definiert wird, liese sich somit 
augenblicklich einsetzen. 

Im Falle einer parametrisierbaren Ebene, die 
beispielsweise die Erkrankungsfälle als Punkte begrenzt 
auf bestimmte Altersgruppen anzeigt, sind nur 
geringfügig mehr Eingriffe im System notwendig. Die 
Nutzung eines bereits bestehenden bzw. die Definition 
eines neuen Parameters wird über Änderungen im 
Java-Code gesteuert.

Die Definitionsdatei des MapServers erlaubt vielfältige 
Eingriffe in die Kartenerzeugung. Sie lässt sich dank 
eines beschreibenden textuellen Dateiformates auch von 
Personen anpassen, die selbst nur wenig 
Programmiererfahrung haben. Zusammen mit Java- und 
SQL-Kenntnissen erlaubt  den Anwendern noch 
weitreichendere Änderungen des Systems.

5.2.3 Aufteilung der Systemkomponenten in Pakete

<Grafikdatei: figures/uml_pakete.png>


<fig:Paketdiagramm-des-EpiDeGIS-Systems>Paketdiagramm des EpiDeGIS-Systems

Pakete erlauben es, die Komponenten eines 
Software-Systems zu größeren Einheiten 
zusammenzufassen. Das Paketdiagramm in Abbildung [fig:Paketdiagramm-des-EpiDeGIS-Systems] zeigt 
die Aufteilung des in dieser Arbeit entwickelten 
Systems. 

Die Klassen in den Paketen haben im Einzelnen folgende Aufgaben:

  Datenbank

Dieses Paket implementiert die Java-Schnittstelle zu 
der PostgreSQL-Datenbank. Die Implementierung basiert 
auf dem Prinzip des "Data Access Objects"-Entwurfsmusters 
(DAO) von Sun [dao:2005]. Dieses Entwurfsmuster versteckt alle 
Zugriffe auf eine Datenbank vor dem Rest der Anwendung.

Alle Datenbankzugriffe in  laufen über dieses Paket. 
SQL-Code verschwindet damit komplett aus dem Java-Code 
aller anderen Klassen.

  Karten

Hier sind alle Klassen zusammengefasst, die für die 
Java-Repräsentation einer Karte benötigt werden. Sie 
implementieren die abstrakten Datentypen Karte, Ebenen 
und Parameter sowie die Kommunikation mit dem MapServer.

  Webanwendung

Die Webanwendung enthält alles, was der Tomcat-Server 
zum Ausführen der serverseitigen -Komponente benötigt. 
Das ist die mit Struts implementierte Webanwendung, der 
Quellcode für die OpenLaszlo-Applikation und alle 
weiteren Ressourcen (JSP, CSS, Grafiken). Die 
Webanwendung verwendet das Karten-Paket als 
Schnittstelle zum Mapserver.

  SaTScan

Ein kleines Java-Programm ist für die automatische 
Ausführung von  zur Cluster-Identifizierung zuständig. 
Es ist in diesem Paket implementiert (siehe Abschnitt [sec:Clusteranalysen-mit-SaTScan]).

  Transfer und Import

Der Java-Code in diesen Paketen implementiert die 
Übertragung und den Import der Typisierungsdaten. Die 
Transfer-Komponente läuft clientseitig (z.B. im NRZM) 
ab, die Import-Anwendung nimmt auf dem Server die Daten 
entgegen und aktualisiert die Datenbank. 

5.2.4 Erweiterungen an externen Schnittstellen

 WMS des MapServers

Abschnitt [sub:Geografische-Informationssysteme] stellt WMS als Schnittstelle zu 
Kartenservern vor und beschreibt die Umsetzung dieses 
Standards im Mapserver. Dank dieses Dienstes existiert 
in  eine bekannte Schnittstelle, über die 
beispielsweise eine desktop-basierte GIS-Anwendung 
Karten des Systems abfragen kann. 

<Grafikdatei: figures/screen_udig.png>


<fig:Screenshot-Udig>Screenshot einer Desktop-GIS-Anwendung die Ebenen aus 
EpiDeGIS einbindet 

Während dieser Arbeit wurde diese Möglichkeit 
experimentell getestet. Abbildung [fig:Screenshot-Udig] zeigt die 
Integration der epidemiologischen Daten des NRZM in der 
Desktop-GIS-Anwendung uDigUser-friendly Desktop Internet GIS [udig:2005]. Dieser Versuch 
demonstriert die Kommunikation mit dem MapServer über 
die WMS-Schnittstelle.

 XML-Repräsentation des Serverzustands

Die serverseitige Komponente der -Webanwendung bietet 
eine  der angebotenen Karte. Diese enthält alle Ebenen 
und alle zulässigen Werte für die Parameter. 

Externe Applikationen könnten diese Informationen 
verwenden, um ihrerseits mit dem System zu 
kommunizieren und die Karten zu nutzen.

5.3 Kapselung des MapServers und Caching

Der MapServer ist ein mächtiges Werkzeug, um komplexe 
epidemiologische Karten zu generieren. Die 
Standardschnittstellen des WMS-Standards führen jedoch 
zu Datenschutzrisiken, wenn dieser Server direkt über 
das Internet zugänglich wäre. 

 kapselt ihn daher so ab, dass der direkte Zugriff nur 
über den serverseitigen Controller erfolgt (siehe 
Abbildung [fig:Verwendung-des-MVC-Architekturmusters]).

5.3.1 <sub:Datenschutz-durch-indirekten>Datenschutz durch indirekten Zugriff

Wie im Abschnitt [sub:Dynamische-Karten] erläutert setzt diese Arbeit das 
Konzept der "Parameter" ein um Attributwerte für Karten 
und Ebenen zu definieren. 

Die vom Anwender übermittelten Attribute werden auf 
Seiten des MapServers innerhalb der SQL-Abfragen 
eingesetzt, welche die Daten für eine Kartenebene zurückliefern.



Listing [lst:mapserver_query] zeigt eine SQL-Query, die alle Fälle aus der 
Datenbank holt, deren Meldedatum zwischen den Werten 
%fromDate% und %toDate% liegt. 

Der MapServer ersetzt die Platzhalter mit den Werten 
von gleichnamigen, über HTTP-Get übermittelten 
Parametern. Der hier vereinfacht dargestellten URL [http://localhost/GetMap?fromDate=012005&toDate=102005] 
liefert eine Karte mit allen Fällen von Januar 2005 bis 
Oktober 2005 zurück.

Sollte ein Anwender direkten Zugriff auf den MapServer 
haben, wäre er aufgrund dieser Art der dynamischen 
Kartenerzeugung in der Lage, Parameterwerte anzugeben, 
die vom Anbieter der Informationen gar nicht vorgesehen 
sind. 

 verhindert das durch einen indirekten, internen 
Zugriff auf den Mapserver. Der serverseitige Controller 
erlaubt nur Parameterwerte, die vorher in der Anwendung 
definiert wurden. 

Die Implementierung für das NRZM setzt diesen 
Schutzmechanistmus ein um z.B. zu verhindern, dass ein 
Kartenausschnitt Berlin in voller Größe abbildet. Aus 
Datenschutzgründen darf für die Öffentlichkeit keine 
Zuordnungsmöglichkeit eines Erkrankungsfalls zu einem 
Stadtteil möglich sein. 

5.3.2 Optimierte Antwortzeiten durch Caching

Ein nützlicher Nebeneffekt der Abschottung des 
MapServers nach außen ist, dass sich dadurch gleich die 
Möglichkeit ergibt, die Geschwindigkeit der 
Kartenerzeugung zu verbessern.

Abschnitt [sec:Definition-von-Karten] stellt Implementierungsbeispiele für 
Kartenebenen vor. Diese setzen teilweise komplexe 
topologische Abfragen an die PostGIS-Komponente der 
Datenbank ein und benötigen unter Umständen eine 
längere Ausführungszeit (über eine Sekunde).

Durch die Implementierung eines Zwischenspeichers an 
der Schnittstelle zum MapServer lässt sich die Zeit für 
die Kartenerzeugung deutlich verringern. 

Der Cache-Mechanismus nimmt dazu den Hashwert des URL, 
der den MapServer veranlasst, eine bestimmte Karte 
auszugeben. Unter diesem Schlüssel wird auf dem Java 
Server bei der ersten Anfrage die Bilddatei der 
erzeugten Karte und der dabei verwendete URL abgelegt. 

Bei einer folgenden Anfrage für die gleiche Karte kann 
das Bild direkt zurückgegeben werden, ohne es erneut 
über den MapServer erzeugen zu müssen.

<Grafikdatei: figures/cache_graph.eps>


<fig:Dauer-der-Kartenerzeugung>Graph der Antwortzeiten mit und ohne Cache

Der Graph in Abbildung [fig:Dauer-der-Kartenerzeugung] zeigt die Ergebnisse einer 
Messung von Antwortzeiten. Hierbei haben fünf Threads 
parallel ein vorher aufgezeichnetes Nutzerverhalten als 
Last für den Server erzeugt. Der Test wurde einmal mit 
und ohne Cache durchgeführt. Der Anstieg zu Beginn der 
Kurve entsteht durch das Hochfahren der Belastung von 
einem auf fünf simulierte Benutzer. 

             || Durchschnitt  | Median   | Maximum  |
-------------++---------------+----------+----------+
-------------++---------------+----------+----------+
  ohne Cache ||   2525 ms     | 1234 ms  | 25094 ms |
-------------++---------------+----------+----------+
  mit Cache  ||    799 ms     | 578 ms   | 9781 ms  |
-------------++---------------+----------+----------+


<tab:Werte-für-Antwortzeiten>Werte für die Antwortzeiten mit und ohne Cache

Die Grafik und die Werte in Tabelle [tab:Werte-für-Antwortzeiten] zeigen deutlich, 
dass die direkte Anfrage an den Mapserver mehr Zeit 
benötigt. Die in beiden Fällen großen Maxima lassen 
sich dadurch erklären, dass während der Messung eine 
noch nicht optimierte Kartenebene aus einem anderen 
Experiment aktiv war. 



Implementierungsdetails

Dieses Kapitel verdeutlicht anhand von Programm- und 
Datenbankfragementen, wie das Software-System zu dieser 
Arbeit implementiert ist. Die jeweils herausgenommenen 
Programmfragmente beziehen sich dabei immer nur auf die 
Teile der Umsetzung, die zum Verständnis des Textes 
nötig sind. Das Element [...] kennzeichnet dabei 
Auslassungen in Quellcode-Listings. Anhand von 
konkreten Beispiele wird der Einsatz aller 
beschriebenen Techniken demonstriert.

Zum besseren Verständnis der Zusammensetzung aller 
Einzelkomponenten von EpiDeGIS stellt Abbildung [fig:Komplettübersicht-des-Systems] eine 
komplette Übersicht dar.

<Grafikdatei: figures/system_komplett.eps>


<fig:Komplettübersicht-des-Systems>Komplettübersicht des Systems EpiDeGIS

6.1 Serverseitige Anwendung

Wenn sich ein Anwender mit der Website von  verbindet, 
laufen serverseitig die Punkte 1-3 der Abbildung [fig:Komplettübersicht-des-Systems] ab. 
Das Laszlo-Servlet kompiliert aus dem LZX-Quellcode 
eine Flash-Datei und liefert diese an den Browser 
zurück. Falls der Quellcode nicht geändert wurde, gibt 
das Servlet eine gespeicherte Version der bereits 
kompilierten Anwendung aus.

Der Browser führt das Programm clientseitig aus und 
stößt erst damit die Erfassung des Benutzers in der 
serverseitigen Komponente von  an. Das 
OpenLaszlo-Servlet läuft zwar ebenfalls auf dem Tomcat, 
ist allerdings nicht mit dem Rest des Software-Systems 
verbunden. Laszlo generiert "lediglich" das 
Flash-Programm aus dem LZX-Quellcode.

6.1.1 Initialisierung der Karte

 Initialisierungsprozess

Sobald der Benutzer die RIA von  öffnet findet der 
eigentliche Initialisierungsvorgang statt. Dieser 
Prozess generiert eine Kartendefinition und speichert 
diese in der Session des Benutzers als Java-Objekt. 

<Grafikdatei: figures/sequenz_createmap.png>


<fig:Sequenzdiagramm-der-Karteninitialisierung>Sequenzdiagramm der Karteninitialisierung

Das Sequenzdiagramm in Abbildung [fig:Sequenzdiagramm-der-Karteninitialisierung] zeigt die Abläufe:

1) Die serverseitige Webanwendung erzeugt das Objekt 
einer Klasse, die von AbstractWmsMap abgeleitet ist.

2) - 3) Über die GeoTools-Bibiliothek wird eine 
Verbindung zum Mapserver hergestellt, um dessen 
Kartendefinition zu erfragen.

4) - 5) Die WMSCapabilities beschreiben u.a. die 
verfügbaren Ebenen und geben diese als Liste von 
Layer-Objekten zurück.

Loop über alle Ebenen:

  6) + 7) Das Layer-Objekt gibt den Namen (eindeutig) und 
  den Titel (beliebig) einer Kartenebene zurück.

  8) -9) Die MapLayerFactory erzeugt anhand des Namens 
  die -Implementierung einer Kartenebene.

 "Produktion" von Ebenen

Die MapLayerFactory ist im Bezug auf das eingesetzte 
Fabrikmethode-Muster [balzert:2000], eine abstrakte Fabrik. Diese 
beauftragt eine konkrete Fabrik mit Herstellung des 
Java-Objekts für eine Ebene. In der Implementierung auf 
das NRZM erledigt das z.B. die NRZMMapLayerFactory. 
Anhand des Namens einer Ebene, die in dem MapServer 
konfiguriert ist, erzeugt sie von MapLayer abgeleitete Objekte.

So gibt ein Aufruf der Form  z.B. ein Objekt der Klasse 
SerogroupsLayer zurück. Diese enthält einen Parameter 
(siehe auch Abschnitt [sub:Dynamische-Karten] und [sub:Änderung-der-Kartendefinition]), der das Filtern nach der 
Serogruppe ermöglicht. 

Falls die Fabrik unter einem Namen keine spezielle 
Ebenenimplementierung vorsieht, liefert sie ein 
MapLayer-Objekt zurück. Diese Standard-Ebene reagiert 
nur auf Änderungen an dem Parameter, der in bestimmte 
Gebiete der Karte zoomt. 

 Prinzipielle Unterstützung von Benutzergruppen

Diese Implementierung erlaubt es dem Entwickler, 
schnell neue Ebenen mit speziellen Parametern zu 
definieren. Weiterhin könnten bei unterschiedlichen 
Benutzergruppen verschiedene Fabriken eingesetzt 
werden, die beispielsweise für den internen Einsatz 
eine Ebene mit detaillierten und für die Öffentlichkeit 
mit groben Filtern produzieren.

Die Erweiterung könnte zudem auch eine Ebene höher 
ansetzen. Das System erzeugt für jeden Benutzer ein 
Objekt des Typs AbstractWmsMap. Dieses stellt die 
eigentliche Schnittstelle zum MapServer dar. Je nach 
konkreter Implementierung könnten hier z.B. 
unterschiedliche "MapFiles" als Karte eingesetzt werden. 

Sobald sich ein Benutzer authentifiziert, kann  z.B. 
eine PublicMap durch eine NRZMMap austauschen und die 
Anwendung neu laden. Implementiert ist bisher nur die 
NRZMMap. Dieses Design ermöglicht jedoch den Einsatz 
von Benutzergruppen.

6.1.2 Export der Karte in unterschiedliche Dateiformate

Nach der Initialisierung liegt in der Benutzer-Session 
ein Kartenobjekt vor. Dieses soll als View in 
verschiedenen Formaten ausgegeben werden (siehe auch 
Abschnitt [sub:Präsentation-der-Informationen]).

Die Implementierung dieser Funktion wendet dabei ein 
von Allen Holub [holub:2004] beschriebenes Konzept an. Dieses 
ersetzt den in der Anfangsphase eingesetzten Ansatz, 
der z.B. XML-Repräsentation der Karte umständlich 
mittels JSP und zu vielen Get-Methoden erzeugt hat. Ein 
früherer Artikel von Holub [holub:2003] hat dabei zu einer 
weitgehenden Vermeidung von Get- und Set-Methoden in 
der Klasse AbstractMap und deren Ableitungen angeregt.

<Grafikdatei: figures/uml_exporter.png>


Klassendiagramm des Exporter-Konzeptes

Die Klasse AbstractWmsMap stellt eine Schnittstelle 
namens Exporter bereit. Über die Methode  übergibt die 
Karte ihre internen Daten an eine Klasse, die das 
Exporter-Interface implementiert. Das Paket Export 
(siehe Abbildung [fig:Paketdiagramm-des-EpiDeGIS-Systems]) enthält in  alle konkreten 
Implementierungen dieser Schnittstelle (Tabelle [tab:Klassen-im-Paket-Export]).

+--------------------------+-------------------------------------------------------------+
| Klassenname              | Aufgabe                                                     |
+--------------------------+-------------------------------------------------------------+
+--------------------------+-------------------------------------------------------------+
| XmlExporter              | erzeugt eine XML-Repräsentation der Karte                   |
+--------------------------+-------------------------------------------------------------+
| AbstractWmsExporter      | nutzt den MapServer zum Kartenexport                        |
+--------------------------+-------------------------------------------------------------+
| WmsInformationeExporter  | liefert Attributinformationen zu einem Punkt auf der Karte  |
+--------------------------+-------------------------------------------------------------+
| WmsImageExporter         | exportiert die Karte als Bild und implementiert das Caching |
+--------------------------+-------------------------------------------------------------+
| WmsLegendExporter        | gibt die Kartenlegende als Bild zurück                      |
+--------------------------+-------------------------------------------------------------+


<tab:Klassen-im-Paket-Export>Klassen im Paket Export und ihre Aufgaben

Die Webanwendung erzeugt z.B. das XML-View mit einem 
XmlExporter-Objekt. Das Programmfragment in Listing [lst:exporter_frag] 
zeigt, wie einfach sich das Exporter-Prinzip anwenden 
lässt. 



6.1.3 <sub:Zustandsänderung-durch-Aktionen>Zustandsänderung durch Aktionen in Struts

<Grafikdatei: figures/uml_formbean.png>


<fig:ActionForm-Bean>"ActionForm Bean"-Klasse für die MoveMapAction
Abschnitt [sub:Wohldefinierte-Zustandsänderungen] stellt das Konzept vor, in dem der 
Controller in der RIA alle Eingriffe in den 
Systemzustand über den serverseitigen Controller 
ausführen muss. Struts (siehe [sub:Web-basierte-Anwendungen]) nimmt als 
Front-Controller alle Anfragen an den Java Server 
entgegen und beauftragt mit deren Bearbeitung so 
genannte "Actions" [struts_doc:2005].

 Beispiel einer implementierten Aktion

Eine an der Schnittstelle zur Verfügung stehende Aktion 
heißt "MoveMap". Über den URL [http://localhost/MoveMap.do?xoffset=0.5&yoffset=0.5] wird eine Verschiebung des 
Kartenausschnitts um 50% der Breite nach linksAnm. des Autors: Beim Schreiben ist mir der kleine 
Implementierungsfehler aufgefallen. Üblicherweise würde 
man bei einem positiven Offset eine Bewegung nach 
rechts erwarten. 
 und um 50% der Höhe nach unten durchgeführt. Zur 
Implementierung der Aktion sind drei Schritte notwendig:

  Umsetzung in der Programmlogik

Dieser Schritt hat noch nichts mit dem Struts-Framework 
zu tun. Um den Kartenausschnitt verschieben zu können, 
muss die AbstractWmsMap zuerst eine entsprechende 
Methode bereitstellen. Der Aufruf von map.move(0.5, 
0.5) führt die Aufgabe aus. Die Methode verschiebt dazu 
einfach die Grenzkoordinaten des Kartenausschnittes um 
den entsprechenden Anteil.

  Implementierung einer "Action" und einer "ActionForm Bean"

Eine in Struts definierte Aktion leitet sich immer von 
der Action-Klasse des Frameworks ab. Sie ist die 
Schnittstelle zwischen einem eingehenden HTTP-Request 
und der Programmlogik (s.o.). Die Daten des Requests 
verpackt Struts automatisch in so genannte "ActionForm Beans"
 (Abbildung [fig:ActionForm-Bean]).

Die Struts-Aktion verwendet diese Java-Container um auf 
HTTP-Parameter zuzugreifen. Das "ActionForm Bean"-Konzept 
definiert noch einiges mehr, diese Funktionalität 
verwendet  jedoch nicht.

Die Implementierung der MoveMapAction nimmt die mittels 
HTTP-Get übertragenen Werte für xOffset sowie yOffset 
und ruft damit move() aus der AbstractWmsMap auf. 
Listing [lst:movemap_frag] zeigt mit der execute-Methode den wesentlichen 
Teil der Aktion.



  Definition des "Action Mappings" und der "Form Bean"

Damit das Struts-Framework weiß, welche Aktion es 
aufrufen muss, wenn eine HTTP-Anfrage über den URL [../MoveMap.do] 
eingeht, benötigt es einen Eintrag in seiner zentralen 
Konfigurationsdatei. Listing [lst:strutsconfig_frag] zeigt den entsprechenden 
Ausschnitt aus dieser Datei.



In dieser minimalen Konfiguration muss lediglich die "
Form Bean"- und die "Action"-Klasse festgelegt werden. Der 
angegebene Pfad legt fest, unter welchem Namen die 
Aktion über HTTP erreichbar ist.

 In EpiDeGIS implementierte Aktionen

Tabelle [tab:Implementierte-Struts-Aktionen] listet alle Aktionen auf, die in diesem System 
implementiert sind. Nur mittels dieser Schnittstellen 
können externe Anwendungen wie z.B. die 
OpenLaszlo-Applikation den Zustand des Servers ändern 
bzw. erfragen.

+----------------------+-------------------------+---------------------------------------------------------------+
|        Alias         |    ""Action-Klasse      |                           Funktion                            |
+----------------------+-------------------------+---------------------------------------------------------------+
+----------------------+-------------------------+---------------------------------------------------------------+
|    Mapbrowser.do     |    (Weiterleitung)      |        öffnet die HTML-Seite mit der eingebetteten RIA        |
+----------------------+-------------------------+---------------------------------------------------------------+
|       Map.do         |    CreateMapAction      | initialisiert die Anwendung und gibt die Karte als XML zurück |
+----------------------+-------------------------+---------------------------------------------------------------+
|      GetMap.do       |      GetMapAction       |            liefert eine Bitmap der aktuellen Karte            |
+----------------------+-------------------------+---------------------------------------------------------------+
|   GetMapLayer.do     |   GetMapLayerAction     |        liefert eine Bitmap einer einzelnen Kartenebene        |
+----------------------+-------------------------+---------------------------------------------------------------+
| GetLegendGraphic.do  | GetLegendGraphicAction  |          liefert eine Bitmap der Legende einer Ebene          |
+----------------------+-------------------------+---------------------------------------------------------------+
|     MoveMap.do       |     MoveMapAction       |                verschiebt den Kartenausschnitt                |
+----------------------+-------------------------+---------------------------------------------------------------+
|    SetParameter      |   SetParameterAction    |               ändert den Wert eines Parameters                |
+----------------------+-------------------------+---------------------------------------------------------------+
|  ToggleLayerState    | ToggleLayerStateAction  |                schaltet eine Ebene an bzw. aus                |
+----------------------+-------------------------+---------------------------------------------------------------+
|   GetFeatureInfo     |  GetFeatureInfoAction   |  liefert Attributinformationen zu einem Punkt auf der Karte   |
+----------------------+-------------------------+---------------------------------------------------------------+
|    Mapbrowser.do     |    (Weiterleitung)      |        öffnet die HTML-Seite mit der eingebetteten RIA        |
+----------------------+-------------------------+---------------------------------------------------------------+


<tab:Implementierte-Struts-Aktionen>Implementierte Struts-Aktionen in EpiDeGIS-Webanwendung

6.2 <sec:Definition-von-Karten>Definition von Karten für den MapServer

Der MapServer steuert alle Details der Kartenerzeugung 
über die "MapFile". Im Bezug auf die Zeilenzahlen in 
Listing [lst:mapserver_simple] erlaubt diese u.a. folgende Einstellungsmöglichkeiten:

3 Grenzen des vom MapServer dargestellten 
Koordinatenbereiches (minx, miny, maxx, maxy)

4,5 Einbindung externer Dateien mit Font- und Symboldefinitionen

6-14 Metaangaben zu dem bereitgestellten WMS

15-24 Definition der angebotenen Ausgabeformate, dem 
Standard-Bildtyp, der Standard-Bildgröße und der 
Hintergrundfarbe. Die Größe der auszugebenden Bitmap 
lässt sich zur Laufzeit auch über den URL angeben.

28-37 Einstellungen zu der Legende

38-83 Definition einer Kartenebene:

41-42 Angaben zur Datenbankverbindung (Typ, Benutzer, 
Passwort und Host)

43-47 Definition der Datenquelle

48 Geometrietyp der Ebene (z.B. Punkte)

49 Datenbankspalte, die den zu der Geometrie 
darstellenden Text (z.B. den Stadtnamen) enthält

50-53 WMS-Metainformationen zu dieser Ebene

54-56 Projektion, in der die Quelldaten vorliegen

57-58 Größe der dargestellten Symbole und Text-Label

59-82 Angaben zur Darstellung der Geometrien

60 Voraussetzung an die Attributdaten aus der 
darzustellenden Datenmenge (z.B. Einwohnerzahl einer 
Stadt größer als 1 Million), damit diese Angaben 
verwendet werden

64-70 Stil, in dem die Geometrien dargestellt werden 
(z.B. rotes Quadrat der Größe 8-16 Pixel mit einem 
schwarzen Rand)

71-81 Definition der Schriftart der angezeigten Textinformation

Die wichtigste Einstellung ist die Definition der 
Datenquelle. Diese erlaubt die direkte Abfrage der 
Datenbank unter Angabe dynamischer Parameter. Listing [lst:data_map] 
zeigt die Verwendung der in Abschnitt [sub:Datenschutz-durch-indirekten] bereits als 
Beispiel eingesetzten SQL-Abfrage in einem DATA-Element.



Das Listing zeigt die Metaangaben, die der MapServer 
benötigt, um die SQL-Query als Datenquelle verwenden zu 
können. USING SRID=4326 gibt an, in welchem 
Koordinatensystem die Daten vorliegen (4326 entspricht 
geografische Länge und Breite), USING UNIQUE case_id 
legt fest, welche Spalte einen eindeutigen 
Schlüsselwert enhält. 

Die folgenden Abschnitte zeigen, wie ausgewählte 
Ebenentypen für die epidemiologischen Karten des NRZM 
in Hinblick auf die SQL-Abfragen implementiert sind.

6.2.1 Inzidenzdarstellung

 kann die Inzidenz für alle in der Datenbank erfassten 
Gebiete berechnen und darstellen. Hierzu müssen zu 
einem Bereich (wie z.B. einem Bundesland) lediglich die 
Einwohnerzahlen vorliegen.

Da bei der Implementierung für die 
Meningokokkenerkrankung alle registrierten 
Erkrankungsfälle auch Neuerkrankungen sind, errechnet 
sich die Jahresinzidenz für ein Gebiet durch folgende 
Formel: 

\frac{Anzahl\, der\, Erkrankungsfaelle\, in\, einem\, Jahr\times100.000}{Anzahl\, der\, Einwohner}

 Dynamische Inzidenzberechnung

Nach dem in Abschnitt [sub:Globale-und-benutzerspezifische] vorgestellten Datenbankkonzept, 
das flexible Hierarchien und Gebiete vorsieht, ist es 
nicht möglich, die Inzidenz in vorher festgelegten 
Tabellen abzuspeichern. Außerdem würden starre Tabellen 
es nicht ermöglichen, Inzidenzberechungen über andere 
Zeiträume anzustellen.

Gelöst ist diese Problemstellung mittels der Topologie. 
Jeder Erkrankungsfall in der Datenbank besitzt eine 
Koordinate und jedes Gebiet ist ein Polygon (jeweils in 
der Spalte the_geom). Die topologische Beziehung "
Erkrankungsfall ist in einem Gebiet aufgetreten" liefert 
wahr oder falsch zurück. Die Abfrage in Listing [lst:count_cases_bayern] 
liefert beispielsweise die Zahl aller Fälle in Bayern zurück.



Diese spezifische Query lässt sich durch weitere 
Bedingungen leicht so erweitern, dass sie die 
Fallzählung für jedes Gebiete vom Typsiehe auch Abbildung [fig:Hierarchische-Speicherung-von-Gebieten] "Bundesland" auf 
einen bestimmten Zeitraum begrenzt durchführt.

 Preis der Dynamik

Leider benötigt die Funktion contains() sehr viel 
Rechenzeit. Tabelle [tab:Rechenzeiten-zur-Zählung] führt diese für drei in 
Deutschland vorkommende Hierarchieebenen auf.

+------------------------------+--------------------+-------------+
|         Gebietstyp           | Datenbankeinträge  | Rechendauer |
+------------------------------+--------------------+-------------+
+------------------------------+--------------------+-------------+
|         Bundesland           |        16          |   7609 ms   |
+------------------------------+--------------------+-------------+
|          Landkreis           |        439         |  23156 ms   |
+------------------------------+--------------------+-------------+
| fünfstellige Postleitzahlen  |       8270         |  22563 ms   |
+------------------------------+--------------------+-------------+


<tab:Rechenzeiten-zur-Zählung>Rechenzeiten zur Zählung der Erkrankungsfälle in einem 
bestimmten Gebietstyp

Auch wenn weitere einschränkende Bedingungen (z.B. 
Zeitraum) die Anzahl der Fälle und damit die Rechenzeit 
verringern, ist sie noch zu lang, um daraus dynamisch 
Karten zu erzeugen.

Mit einer Zuordnungstabelle lässt sich die Abfragedauer 
entscheidend verbessern. Die Zuordnung eines 
Erkrankungsfalles zu einem Gebiet muss dabei nur 
erneuert werden, wenn neue Gebiete bzw. Falldaten in 
die Datenbank eingetragen werden. Tabelle [tab:Optimierte-Rechenzeiten] zeigt die 
Messergebnisse mit Hilfe der Zuordnungstabelle 
contains_area_case. Diese liegen in dem brauchbaren 
Bereich von unter einer Sekunde.

+------------------------------+--------------------+-------------+
|         Gebietstyp           | Datenbankeinträge  | Rechendauer |
+------------------------------+--------------------+-------------+
+------------------------------+--------------------+-------------+
|         Bundesland           |        16          |   203 ms    |
+------------------------------+--------------------+-------------+
|          Landkreis           |        439         |   328 ms    |
+------------------------------+--------------------+-------------+
| fünfstellige Postleitzahlen  |       8270         |   391 ms    |
+------------------------------+--------------------+-------------+


<tab:Optimierte-Rechenzeiten>Durch Zuordnungstabelle optimierte Rechenzeit (vgl. 
Tabelle [tab:Rechenzeiten-zur-Zählung])

 Finale Implementierung

Die Datenquellendefinition für die Inzidenz-Ebene für 
den Einsatz im NRZM ist in Listing [lst:incidence_data] abgedruckt. 

Die Abfrage führt folgende Aufgaben aus:

Zeile 3-6 Diese vier Zeilen berechnen die Jahresinzidenz 
zwischen zwei begrenzenden Daten von monatlicher 
Auflösung. Die Berechnung führt eine einfache Inter- 
bzw. Extrapolation aus, wenn der Zeitraum größer oder 
kleiner einem Jahr ist.

Z. 12-14 Die Inzidenzberechnung erfolgt nur für Fälle 
der über den Parameter %SEROGROUPS% angegebenen 
Serogruppe(n) (z.B. "'B','C'"), deren...

Z. 14-17 ...Meldedatum (als Monate umgeschrieben) zwischen 
den angegebenen Grenzdaten liegt.

Zeile 18 Die Abfrage verwendet nur Gebiete der 
Hierarchieebene, die über den Wert des Parameters mit 
dem Namen %INCITIER% festgelegt ist.

Die Inzidenz-Ebene stellt mittels dieser 
Implementierung die Inzidenz in einem beliebigen Gebiet 
in der Datenbank durch eine Färbung dar. Die Berechnung 
arbeitet unabhängig von den zugrunde liegenden 
Grenzpolygonen. Dank der Zuordnungstabelle wird die 
Karte trotz dieser Dynamik schnell erzeugt.

6.2.2 Darstellung von Clustern

Die Cluster-Ebene stellt die von der SaTScan-Komponente 
identifizierten Erkrankungshäufungen dar. Ein Cluster 
besitzt zwei für die geografische Darstellung wichtige 
Attribute: Das Gebiet, in dem der Mittelpunkt liegt, 
und einen Radius, welcher die Ausbreitung markiert.

 PostGIS erzeugt Kreise

Sobald SaTScan einen Cluster entdeckt hat, legt  diesen 
in der Datenbank ab. An dieser Stelle wäre es ohne 
weiteres möglich, den Umkreis als Geometrie mit in der 
Datenbank zu speichern. Um Datenredundanz zu vermeiden, 
geht die Implementierung in eine andere Richtung.

Der Clusterumkreis ist letztlich nichts anderes als ein 
Kreis um den Mittelpunkt des zentralsten Gebietes mit 
dem entsprechenden Radius in Kilometern. Das PostGIS 
Benutzerhandbuch [postgis_doc:2005] definiert die folgende Methode:

  Buffer(geometry,double,[integer]) Gibt eine Geometrie 
  zurück die alle Punkte beinhaltet, deren Abstand von 
  der im ersten Argument angegebenen Geometrie kleiner 
  oder gleich dem Wert im zweiten Argument ist. 
  Berechnungen werden im Koordinatensystem der 
  Geometrie ausgeführt. Der optionale dritte Parameter 
  gibt die Anzahl der Segmente an, mit denen ein 
  Viertelkreis angenähert wird (Standard ist 8).

Diese Funktion leistet genau das Gewünschte, wenn sie 
mit dem Mittelpunkt des Clusters und dessen Radius 
aufgerufen wird. Listing [lst:buffer_frag] zeigt den entsprechenden 
Ausschnitt aus der SQL-Query.





Die Erdkrümmung ist dafür verantwortlich, dass neben 
den eigentlichen Methoden centroid und buffer noch zwei 
weitere benötigt werden. 

In dem auf geometrische Länge und Breite basierendem 
Koordinatensystem mit dem Code 4326 würde wegen der 
unterschiedlichen Abstände von Längen- und 
Breitenkreisen eine Ellipse anstelle des Kreises 
entstehen. Aus diesem Grund wird in Zeile vier der 
Mittelpunkt nach Gauß-Krüger transformiert, um dort den 
Kreis mit dem Radiusdie Einheit im Gauß-Krüger-Koordinatensystem ist Meter, 
daher die Multiplikation mit 1000
 zu erzeugen. Anschließend wird der "Buffer" wieder 
rücktransformiert.

 Sonderfall: Radius 0 Kilometer

SaTScan gibt bei Clustern, die nur in einem Landkreis 
auftreten, einen Radius von 0 Kilometern zurück. Mit 
der obigen Implementierung wären sie auf der Karte 
nicht darstellbar. Mittels einer Fallunterscheidung im 
SELECT-Statement der Cluster-Ebene werden diese Cluster 
gesondert behandelt. Dabei wird ein Kreis erzeugt, der 
den Landkreis annähernd umschließt.

6.2.3 Streuung von Punktinformationen

Bei der NRZM-Umsetzung der Serogruppen-Ebene, die alle Meningokok
ken-Erkrankungsfälle als Symbole auf der Karte anzeigt, 
hat sich in Verbindung mit dem MapServer ein Problem ergeben:

Wenn mehrere Fälle in der gleichen Stadt aufgetreten 
sind, hat der MapServer diese nur mit einem Symbol an 
der entsprechenden Koordinate dargestellt. Die 
Bewertung von Häufungen bestimmter Serogruppen ist 
dadurch nicht möglich, da der Anwender nicht 
unterscheiden kann, ob z.B. einer oder zehn Fälle 
aufgetreten sind.

Da der MapServer innerhalb einer Ebene kein Mittel 
bereit stellt, Punktinformationen um die eigentliche 
Koordinate zu streuen, muss die Datenbankabfrage diese 
Aufgabe erledigen.



Listing [lst:cases_random] zeigt die Definition einer "Sicht" (siehe auch [sub:Funktionen-und-Sichten]
), welche die Koordinaten aller in der cases-Tabelle 
erfassten Fälle um einen zufälligen Betrag in x- und 
y-Richtung transformiert.

6.3 Clientanwendung mit OpenLaszlo

Der folgende Abschnitt geht auf zwei Details der 
Anwendungsprogrammierung mit OpenLazlo ein. Er bietet 
keine Anleitung zur Programmierung in der LZX-Sprache, 
sondern vielmehr eine Vorstellung von zwei 
interessanten Konzepten. Details zur Programmierung in 
OpenLaszlo finden sich in der umfassenden Dokumentation [openlaszlo_doc:2005]
. Diese wird jedoch für das Verständnis des Folgenden 
nicht benötigt.

6.3.1 <sub:Dynamischer-Aufbau-der-GUI>Dynamischer Aufbau der Benutzeroberfläche

In Abbildung [fig:Komplettübersicht-des-Systems] ist zu erkennen, dass sich die 
Benutzeroberfläche der RIA mittels der 
XML-Repräsentation des Serverzustandes initialisiert. 
Die Abschnitte [sub:Dynamische-Karten] und [sub:Änderung-der-Kartendefinition] behandeln das Konzept von 
dynamischen Ebenen und Parametern.

 Replikation durch XML-Daten

OpenLazlo ermöglicht es durch eine Technik namens "databinding"
, dynamisch Elemente in der Benutzeroberfläche eine 
Flash-Anwendung zu erzeugen. Listing [lst:databinding] zeigt ein 
anschauliches Beispiel [wolff:2005] dieser Funktion:



Zeilen 2-9 definieren inline im Programm ein "dataset", 
das beliebige XML-Daten enthalten kann. 

Z. 10-13 erzeugen ein so genanntes "view". Der Begriff 
bezeichnet in OpenLaszlo ein später in der Anwendung 
sichtbares Containerelement. Das Attribut datapath 
dieses Elements löst die Replikation aus.

Z. 11+12 sorgen dafür, dass die Daten aus dem XML in der 
Flash-Anwendung angezeigt werden.

<Grafikdatei: figures/databinding.png>


<fig:Ausgabe-des-Programms>Ausgabe des Programms in Listing [lst:databinding]

Abbildung [fig:Ausgabe-des-Programms] zeigen die Ausgabe der entstehenden 
Flash-Anwendung. Sie verdeutlicht das Prinzip des "databinding":

Über das Attribut datapath weiß die Anwendung, dass das "view"
 in Zeile 10-13 explizit mit den Daten unter dem Pfad 
myData:/people/* verbunden ist. Die Sprache mit der 
OpenLaszlo den Pfad beschreibt ist XPath [clark:2005].

Der in Laszlo integrierte Replikations-Mechanismus 
arbeitet mit diesen Pfadangaben. Das "view" wird von ihm 
für jedes Datenelement kopiert, das sich unter <people> 
befindet. In dem Beispiel werden dabei jeweils für Tim, 
Ron, Kelly und Adam zwei Textelemente horizontal 
aneinander gereiht (layout="axis:'x'"). 

Das erste schreibt den Namen des XML-Elementes und das 
zweite den Inhalt. Die Pfadangaben innerhalb des 
Containers werden dabei relativ zu dessen Pfad interpretiert.

Durch die Angabe layout="spacing:2" ordnet das 
<canvas>-Element die vier replizierten <view>'s 
untereinander (die Standardachse ist y) mit einem 
Abstand von zwei an.

 XML Datenquellen

OpenLaszlo nimmt die Daten für die Replikation aus drei 
möglichen Quellen entgegen. Entweder Inline-XML (s.o.), 
auf dem Webserver liegende XML-Dateien oder XML-Daten, 
die über einen URL geladen werden.

 setzt die letztgenannte Quelle ein. Die vom Server 
angebotene Karte wird als XML von der Flash-Anwendung 
eingelesen und zum Aufbau der grafischen 
Benutzeroberfläche verwendet. 

 Implementierung am Beispiel eines Auswahlparameters 

Listing [lst:map] zeigt die XML-Repräsentation einer einfachen 
Karte. Am Beispiel des Kartenparameters mit dem Namen 
areaId (Zeile 3-10), soll die Replikation von Elementen 
der Benutzeroberfläche in  demonstriert werden.

Listing [lst:mapbrowser_frag] enthält die beiden Programmstellen, die dafür 
verantwortlich sind, dass in der GUI ein Auswahlfeld 
für den zu betrachtenden Kartenausschnitt erscheint 
(siehe Abbildung [fig:Konkrete-Umsetzung-Parameter]):

Zeile 2-7 definieren eine Datenquelle, deren Ziel die 
Aktion von Struts ist, welche die Karte als XML 
zurückgibt (siehe Tabelle [tab:Implementierte-Struts-Aktionen]). In Zeile vier wird nach 
obigen Prinzip ein Element der Klasse selectparameter 
so oft repliziert, wie es <selectparameter>-Elemente 
unter den Wurzelelement <map> in Listing [lst:map] gibt. In 
diesem Fall ist es nur der eine, welcher die Auswahl 
des Gebietes ermöglicht.



Die Klasse selectparameter ist in einer externen 
LZX-Quelldatei implementiert. Sie erzeugt die 
eigentliche Dropdown-Liste anhand der <value>-Elemente 
und informiert den Rest der Applikation, wenn der 
Anwender den Parameterwert ändert.

6.3.2 Kommunikation zwischen Laszlo und Struts

Die Laszlo-Applikation kommuniziert mit Struts über die 
in Abschnitt [sub:Zustandsänderung-durch-Aktionen] angegebenen Aktionen. Der Server 
antwortet dabei auf Anfragen mit XML-Fragmenten. Diese 
informieren über den Erfolg, Misserfolg und Ergebnisse 
der gewünschten Zustandsänderung. Die RIA verarbeitet 
die Serverantworten mittels dem gleichen Prinzip, das 
schon bei dem dynamischen Aufbau der GUI in Abbildung [sub:Dynamischer-Aufbau-der-GUI] 
Anwendung findet.

Listing [lst:mapbrowser_frag2] zeigt den Programmteil des Kartenbetrachters, 
in dem die SetParameter-Aktion von Struts (siehe 
Tabelle [tab:Implementierte-Struts-Aktionen]) angewendet, und deren Ausgabe 
entgegengenommen wird:



Zeile 4 definiert wie Zeile 7 in Listing [lst:mapbrowser_frag] die Datenquelle.

Z. 7-12 zeigen den Ausschnitt einer Methode, die eine 
Anfrage an die Datenquelle stellt. Zwei HTTP-Parameter 
werden für die Query mit angegeben. Struts verändert 
mittels der SetParameter-Aktion den Wert eines 
Parameters (name) auf den angegebenen Wert (value).

Z. 14 definiert einen Zeiger auf den Pfad der in Zeile 4 
definierten Datenquelle. 

Z. 15 Sobald sich die Daten ändern, auf die der 
datapointer zeigt, wird das Ereignis ondata ausgelöst 
und die entsprechende Methode ausgelöst.

Listing [lst:setparam_result] zeigt die Antort der Aktion [../SetParameter.do?name=SEROGROUPS&value='B']. Diese setzt den 
Parameter mit dem Namen SEROGROUP auf den Wert "'B'". Der 
Server nimmt die Zustandsänderung an und antwortet mit 
einem bestimmten XML-Fragment.



Dieses enthält als Wurzel das Element <result>. Darin 
folgen zwei <update>-Elemente. Diese deuten der 
Laszlo-Anwendung an, dass sich durch die Aktion sowohl 
die Serogruppen- als auch die Inzidenz-Ebene geändert hat.

Sobald die Serverantwort bei Laszlo ankommt, löst sie 
das ondata-Ereignis aller mit der Datenquelle 
SetParameter verknüpften datapointer aus. Auch die 
Methode in Listing [lst:mapbrowser_frag2] , Zeile 14 wird angestoßen und kann 
auf die Antwort reagieren. Im obigen Bespiel wird sie 
die beiden Ebenen neu laden.

6.4 <sec:Clusteranalysen-mit-SaTScan>Serverseitige Clusteridentifizerung mittels SaTScan

Mit SaTScan setzt  ein Werkzeug ein, das bereits viele 
Epidemiologen zu Identifizierung von Clustern 
verwenden. SaTScan lässt sich mit einer grafische 
Benutzeroberfläche bedienen, über die sich alle 
Parameter der Analyse einstellen lassen. Nach einem 
Durchlauf gibt es die Ergebnisse in einem Bericht aus 
(siehe Listing [lst:satscan_out]). 

Für den Einsatz am eigenen Rechner ist die Analyse mit 
Hilfe einer GUI sehr komfortabel, im automatisierten 
serverseitigen Einsatz jedoch ungeeignet. Da sich 
SaTScan aber auch über die Kommandozeile ausführen 
lässt, ist ein automatisierter Aufruf aus Java heraus 
möglich. 

 Terminplanung von Analysen

Das Paket Satscan im Software-System EpiDeGIS 
implementiert die Verbindung von SaTScan und Java. Für 
die Implementierung der automatisierten Ausführung war 
es wichtig, dass der Server die Clusterberechnungen zu 
einer beliebigen Zeit ausführen kann. Die 
hardwarelastigen Berechnungen können so in der Nacht 
getätigt werden. Das bedeutet, dass die Ablaufplanung 
einen Analysevorgang unter Umständen vor dem Ende 
abbricht. Dies darf unter keinen Umständen zu einer 
Unterschlagung einer Berechnung führen. 

Die Implementierung des automatisierten SaTScan-Aufrufs 
speichert aus diesem Grund alle geplanten Analysen in 
der Datenbank. Die Grundlage bildet dabei eine Tabelle, 
die so genannte "SaTScan-Jobs" enthält. Hierbei handelt 
es sich um geplante Ausführungen, die in bestimmten 
Zeitabständen durchgeführt werden sollen. Der Job 
speichert neben der Ausführungsart (wöchentlich, 
monatlich, jährlich) und dem letzten Ausführungsdatum, 
auch alle in diesem Job für die Ausführung von SaTScan 
verwendeten Einstellungen.

Ein eingesetzter Job für das NRZM lautet beispielsweise "
weekly prospective" (siehe Abschnitt [sub:Automatische-Identifizierung-Cluster]). In diesem ist 
festgelegt, dass  jede Woche eine prospektive 
Clusteridentifizerung durchführen soll. Diese muss 
jeden einzelnen in einem Beobachtungszeitraum von 100 
Tagen aufgetretenen Feintyp das Programm SaTScan 
ausführen. 

 Ausführung von SaTScan

Eine weitere Tabelle verwaltet alle diese atomaren 
Ausführungen. Sie speichert in drei Spalten jeweils die 
Jobnummer, das ursprünglich geplante Ausführungsdatum 
und die Nummer des zu analysierenden Feintyps. Die 
Jobverarbeitung füllt die Tabelle mit den Daten der für 
die zur Erledigung eines Jobs nötigen Analysen.

Die eigentliche Ausführung von SaTScan geht 
folgendermaßen von statten: 

<Grafikdatei: figures/db_satscan.eps>


<fig:Datenbankstruktur-zum-Planen>Datenbankstruktur zum Planen von SaTScan-Ausführungen 
und Speichern der Ergebnisse

Die erste auf dem Ablaufplan stehende Analyse wird aus 
der Tabelle abgefragt.  kann dabei durch die Jobnummer, 
den Feintyp und das Datum rückschließen, welche 
Erkrankungsfälle es für die Clusteridentifizierung 
berücksichtigen muss. Anhand dieser Daten lassen sich 
die von SaTScan benötigten Eingabedateien generieren. 

SaTScan wird von Java aus als externes Programm 
aufgerufen. Es führt die Analyse mit Hilfe der 
Eingabedateien aus. Nach einem erfolgreichen Lauf 
generiert es verschiedene Ergebnisdateien [kulldorff:2005]. EpiDeGIS 
nimmt alle Informationen aus den jeweiligen Dateien und 
erzeugt daraus ein Objekt der Klasse SatscanCluster. 
Über diesen Container wird das Ergebnis in die 
Datenbank übertragen.

Erst an diesem Punkt ist die Analyse eines Feintyps 
beendet und der entsprechende Eintrag aus der Tabelle 
der geplanten Ausführungen wird gelöscht. Abbildung [fig:Datenbankstruktur-zum-Planen] 
zeigt die Relationen in der Datenbank. Das zentrale 
Gebiet bzw. der Feintyp in der Cluster-Tabelle, sind 
dabei Fremdschlüssel für andere, hier nicht abgebildete Tabellen.

 Vorteile und Implementierung

Die atomare SaTScan-Analyse hat den Vorteil, dass sie 
die zum Teil zeitintensiven Berechnungen Stück für 
Stück ausführt. Eine retrospektive Analyse über einen 
großen Zeitraum kann insgesamt mehrere Tage benötigen. 
Der Anteil für einen Feintyp beträgt dabei nur eine 
halbe Stunde.



<cha:Zusammenfassung-und-Ausblick>Zusammenfassung und Ausblick

7.1 Zusammenfassung

7.2 Erweiterungsmöglichkeiten

7.2.1 Integration des Statistikpaketes R

7.2.2 Animationen über die Dimension Zeit

7.2.3 Ausbau der Benutzeroberfläche

 Speedtyping

 Automatisierte Alarmmeldungen



Softwaresystem EpiDeGIS

A.1 Installationsanleitung unter Linux

A.1.1 Grundlagen

  Manuelle Installation mit configure:

Da es für manche dieser Komponenten kein 
Installationspaket gibt, soll hier kurz auf den 
manuellen Kompilationsvorgang eingegangen werden. 
Dieser ist aber dank mitgelieferter 
Konfigurationsskripten mit wenig Aufwand verbunden. Der 
grundlegende Ablauf zur Installation eines 
Softwarepaketes aus dessen Quellen folgt meistens 
folgendem Muster.

1. Der Programmquellcode wird von der jeweiligen 
  Website herunter geladen. 

2. Die Dateien liegen meistens gepackt im Format tar.gz 
  vor und müssen dann mit dem Befehl tar -zxvf 
  paket-xy-1.0.tar.gz in ein Verzeichnis entpackt werden.

3. Nach einem Wechsel in dieses Verzeichnis muss der 
  Befehl ./configure ausgeführt werden. Das 
  Konfigurationsskript untersucht das System daraufhin, 
  ob es alle Voraussetzungen erfüllt und gibt 
  gegebenenfalls Hinweise auf unerfüllte Abhängigkeiten.

4. Ein fehlerfreier Ablauf des Konfigurationsskriptes 
  produziert eine Datei mit dem Namen Makefile. Mit dem 
  Befehl make wird die Software kompiliert.

5. Abschließend kann das Paket mit make install auf dem 
  System installiert werden. Hierzu sind idR. 
  Administrationsrechte erforderlich.

A.1.2 Installation der benötigten Softwarekomponenten

A.1.3 Einrichtung der Datenbank

A.1.4 Konfiguration des Tomcat Servlet-Containers

A.1.5 Installation und Einrichtung der EpiDeGIS-Komponenten

 Import der Datenbank

 Kartendefinition für den Mapserver

 Serverseitige Webanwendung

 Datenübertragung und Import

 Clusteranalyse

A.2 Clientseitiger Kartenbetrachter

A.2.1 Benutzeroberfläche

A.2.2 Klassen

A.3 Serverseitiger Kartenverwalter

A.3.1 Konfiguration

A.3.2 Klassen

A.4 PostgreSQL Datenbank

A.4.1 <sub:Tabellen>Tabellen

A.4.2 Abfragen

A.4.3 <sub:Funktionen-und-Sichten>Funktionen und Sichten

A.5 Automatisierte Clusteranalyse

A.6 Mapserver zur Kartenerzeugung

A.7 Datenübertragung und Import

A.7.1 Clientseitige Datenübertragung

A.7.2 Serverseitiger Import



Datei-Listings











Abkürzungen

AGI Arbeitsgemeinschaft Influenza

ANSI American National Standards Institute

BMGS Bundesministerium für Gesundheit und Soziale Sicherung

CSS Cascading Style Sheets

CSV Character Separated Values bzw. Comma Separated Values

DAO Data Access Objects

DBMS Datenbankmanagementsystem

ECDC European Centre for Disease Prevention and Control 

EpiDeGIS Projektname für das in dieser Diplomarbeit 
erstellte Softwaresystem

ESRI Environmental Systems Research Institute

GIF Graphics Interchange Format

GIS Geografisches Informationssystem

GUI Graphical User Interface, Grafische Benutzeroberfläche

HTML Hypertext Markup Language

IDC International Data Corporation

IfSG Infektionsschutzgesetz oder Gesetz zur Verhütung 
und Bekämpfung von Infektionskrankheiten beim Menschen

ISO International Organization for Standardization

JSP JavaServer Pages

LLR Log Likelihood Ratio

MVC Model View Controller (Architekturmuster)

NRZM Nationales Referenzzentrum für Meningokokken

OGC Open Geospatial Consortium

ORDBMS objektrelationales Datenbankmanagementsystem

OSS Open Source Software

RIAs Rich Internet Applications

RKI Robert Koch-Institut

SFS Simple Features Specification

SMI Swedish Institute for Infectious Disease Control

SQL Structured Query Language

SWF Small Web Format / Shockwave Flash

URL Uniform Resource Locator

W3C World Wide Web Consortium

WMS Web Map Service

WWW World Wide Web

XML Extensible Markup Language



List of Figures






List of Tables











